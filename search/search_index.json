{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sistemas Hardware-Software \u00b6 Bem vindo ao curso de Sistemas Hardware-Software 2022/1. Professor : Maciel Calebe Vidal Professor auxiliar : Antonio Deusany de Carvalho Junior Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamento: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site","title":"Home"},{"location":"#sistemas-hardware-software","text":"Bem vindo ao curso de Sistemas Hardware-Software 2022/1. Professor : Maciel Calebe Vidal Professor auxiliar : Antonio Deusany de Carvalho Junior","title":"Sistemas Hardware-Software"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamento: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Aulas \u00b6 SEG 13:30 - 15:30 (presencial) QUI 15:45 - 17:45 (presencial) Atendimento: QUA 09:00 - 10:30 (remoto pelo Teams) Entregas de Atividades e Labs \u00b6 Data in\u00edcio Atividade/Lab Como entregar Prazo 21/02 01-inteiros Github (Lembre de Criar repo e Configurar webhook ) 25/02 23h59 07/03 02-funcoes Github 11/03 23h59 07/03 01-hackerlab Github 30/03 23h59 13/03 03-condicionais-funcoes Github 18/03 23h59 16/03 04-loops Github 23/03 23h59 21/03 05-variaveis-locais Github 25/03 23h59 Provas \u00b6 Labs de C : 18/02 (aula com Hashi). AI : a definir AF : a definir SUB : a definir Delta : a definir","title":"Entregas e Prazos"},{"location":"sobre/#aulas","text":"SEG 13:30 - 15:30 (presencial) QUI 15:45 - 17:45 (presencial) Atendimento: QUA 09:00 - 10:30 (remoto pelo Teams)","title":"Aulas"},{"location":"sobre/#entregas-de-atividades-e-labs","text":"Data in\u00edcio Atividade/Lab Como entregar Prazo 21/02 01-inteiros Github (Lembre de Criar repo e Configurar webhook ) 25/02 23h59 07/03 02-funcoes Github 11/03 23h59 07/03 01-hackerlab Github 30/03 23h59 13/03 03-condicionais-funcoes Github 18/03 23h59 16/03 04-loops Github 23/03 23h59 21/03 05-variaveis-locais Github 25/03 23h59","title":"Entregas de Atividades e Labs"},{"location":"sobre/#provas","text":"Labs de C : 18/02 (aula com Hashi). AI : a definir AF : a definir SUB : a definir Delta : a definir","title":"Provas"},{"location":"aulas/01-inteiros/","text":"01 - Inteiros na CPU \u00b6 Os exerc\u00edcios da aula de hoje est\u00e3o no execut\u00e1vel bases_e_sinais . Aula com atividade para entrega! Confira em Conte\u00fados no Blackboard como criar seu reposit\u00f3rio para entregas e configurar o servidor de testes. Nesta atividade, \u00e9 esperado que voc\u00ea realize diversas convers\u00f5es entre bases. O que voc\u00ea precisa fazer \u00e9: 1. Rodar programa bases_e_sinais 2. Colocar sua solu\u00e7\u00e3o em solucao.txt 3. Verificar se tudo est\u00e1 ok rodando (a saida final do programa \u00e9 Exerc\u00edcio correto! ) Ent\u00e3o, quando o execut\u00e1vel bases_e_sinais for chamado com bases_e_sinais < solucao.txt o esperado \u00e9 que seja obitido na sa\u00edda o texto Exerc\u00edcio correto! . Assim, tudo est\u00e1 Ok e voc\u00ea pode fazer o release! Boa atividade!","title":"01 - Inteiros na CPU"},{"location":"aulas/01-inteiros/#01-inteiros-na-cpu","text":"Os exerc\u00edcios da aula de hoje est\u00e3o no execut\u00e1vel bases_e_sinais . Aula com atividade para entrega! Confira em Conte\u00fados no Blackboard como criar seu reposit\u00f3rio para entregas e configurar o servidor de testes. Nesta atividade, \u00e9 esperado que voc\u00ea realize diversas convers\u00f5es entre bases. O que voc\u00ea precisa fazer \u00e9: 1. Rodar programa bases_e_sinais 2. Colocar sua solu\u00e7\u00e3o em solucao.txt 3. Verificar se tudo est\u00e1 ok rodando (a saida final do programa \u00e9 Exerc\u00edcio correto! ) Ent\u00e3o, quando o execut\u00e1vel bases_e_sinais for chamado com bases_e_sinais < solucao.txt o esperado \u00e9 que seja obitido na sa\u00edda o texto Exerc\u00edcio correto! . Assim, tudo est\u00e1 Ok e voc\u00ea pode fazer o release! Boa atividade!","title":"01 - Inteiros na CPU"},{"location":"aulas/02-ram/","text":"02 - Representa\u00e7\u00e3o de dados em RAM \u00b6 Experimentos \u00b6 Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles e coloque suas sa\u00eddas abaixo. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Para compilar cada .c , utilize: $ gcc -Wall -pedantic experimento0.c -o e0 Question Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Representa\u00e7\u00e3o de struct em RAM \u00b6 A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Warning Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Example Compile e execute parte1.c . Example Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Example A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Question Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Confira suas respostas com parte1.c . Examinando a execu\u00e7\u00e3o de programas usando gdb \u00b6 Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Example Para compilar um programa com suporte a debugging usamos a flag -g do gcc $ gcc -g -Wall -pedantic parte2.c -o parte2 Siga os passos abaixo para para carregar um programa usando o gdb . Lance o gdb e passe para ele seu programa: $ gdb ./parte2 Isto nos colocar\u00e1 em um prompt esperando comandos. Para rodar o programa at\u00e9 o fim execute (gdb) run Para sair, (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser vista em https://sourceware.org/gdb/current/onlinedocs/gdb/index.html#Top . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Question Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Question O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Execute-o e veja o que acontece. Example Use info para mostrar as fun\u00e7\u00f5es e vari\u00e1veis globais que existem em parte2 . Warning Muitos dos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Question Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Example Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Mostre o valor inicial de global_var usando este comando e compare com o visto no arquivo parte2.c . Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos de C ( casting ) pode ser \u00fatil aqui. Example Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o , entenda como usar o comando x e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Em seguida, teste-o e verifique que ele funcionou corretamente. Dicas : volte nos exerc\u00edcios anteriores e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Example global_array tem tipo short . Ou seja, \u00e9 formado por dois bytes. Mostre agora o conte\u00fado de cada um deles. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Example Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"02 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/02-ram/#02-representacao-de-dados-em-ram","text":"","title":"02 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/02-ram/#experimentos","text":"Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles e coloque suas sa\u00eddas abaixo. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Para compilar cada .c , utilize: $ gcc -Wall -pedantic experimento0.c -o e0 Question Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa.","title":"Experimentos"},{"location":"aulas/02-ram/#representacao-de-struct-em-ram","text":"A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Warning Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Example Compile e execute parte1.c . Example Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Example A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Question Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Confira suas respostas com parte1.c .","title":"Representa\u00e7\u00e3o de struct em RAM"},{"location":"aulas/02-ram/#examinando-a-execucao-de-programas-usando-gdb","text":"Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Example Para compilar um programa com suporte a debugging usamos a flag -g do gcc $ gcc -g -Wall -pedantic parte2.c -o parte2 Siga os passos abaixo para para carregar um programa usando o gdb . Lance o gdb e passe para ele seu programa: $ gdb ./parte2 Isto nos colocar\u00e1 em um prompt esperando comandos. Para rodar o programa at\u00e9 o fim execute (gdb) run Para sair, (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser vista em https://sourceware.org/gdb/current/onlinedocs/gdb/index.html#Top . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Question Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Question O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Execute-o e veja o que acontece. Example Use info para mostrar as fun\u00e7\u00f5es e vari\u00e1veis globais que existem em parte2 . Warning Muitos dos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Question Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Example Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Mostre o valor inicial de global_var usando este comando e compare com o visto no arquivo parte2.c . Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos de C ( casting ) pode ser \u00fatil aqui. Example Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o , entenda como usar o comando x e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Em seguida, teste-o e verifique que ele funcionou corretamente. Dicas : volte nos exerc\u00edcios anteriores e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Example global_array tem tipo short . Ou seja, \u00e9 formado por dois bytes. Mostre agora o conte\u00fado de cada um deles. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Example Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"Examinando a execu\u00e7\u00e3o de programas usando gdb"},{"location":"aulas/03-arquitetura-x86/","text":"03 - Arquitetura x86-64 \u00b6 No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o . Parando e continuando a execu\u00e7\u00e3o de um programa. \u00b6 Compile funcoes.c usando as flags: $ gcc -Og -g -Wall -std = c99 funcoes.c -o funcoes Tip Na compila\u00e7\u00e3o, -Og ir\u00e1 permitir otimiza\u00e7\u00f5es de c\u00f3digo que n\u00e3o interfiram no debugging. J\u00e1 o par\u00e2metro -g ir\u00e1 tornar dispon\u00edveis informa\u00e7\u00f5es \u00fateis para o debugging (como tipos de vari\u00e1veis e cabe\u00e7alhos das fun\u00e7\u00f5es) Question Abra o execut\u00e1vel com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Example O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Example Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Example Use o comando break funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Example Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta da Tarefa 2 e escreva abaixo suas novas conclus\u00f5es. Example O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Dicas : se a primeira instru\u00e7\u00e3o for endbr64 , execute stepi mais uma vez! use disas de novo verifique novamente o conte\u00fado de %edi Example Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Question Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? Example Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Example Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado no endere\u00e7o descoberto no exerc\u00edcio anterior. Confira seu resultado com o c\u00f3digo. Example Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine. Endere\u00e7amento relativo e vari\u00e1veis globais \u00b6 Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Example Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Example Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Question Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Question Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Question Anote abaixo o endere\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Desenho de acesso a mem\u00f3ria usando %rip A figura abaixo ilustra como funciona o endere\u00e7amento usando o registrador %rip . Note que os deslocamentos s\u00e3o diferentes pois o endere\u00e7o da instru\u00e7\u00e3o atual \u00e9 diferente. Por\u00e9m, o resultado final do endere\u00e7o calculado em ambas instru\u00e7\u00f5es \u00e9 o mesmo, indicando que ambas se referem ao mesmo local na mem\u00f3ria. Example Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Question Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Question Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf . Encontre ent\u00e3o o endere\u00e7o das strings de formata\u00e7\u00e3o e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"03 - Arquitetura x86-64"},{"location":"aulas/03-arquitetura-x86/#03-arquitetura-x86-64","text":"No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o .","title":"03 - Arquitetura x86-64"},{"location":"aulas/03-arquitetura-x86/#parando-e-continuando-a-execucao-de-um-programa","text":"Compile funcoes.c usando as flags: $ gcc -Og -g -Wall -std = c99 funcoes.c -o funcoes Tip Na compila\u00e7\u00e3o, -Og ir\u00e1 permitir otimiza\u00e7\u00f5es de c\u00f3digo que n\u00e3o interfiram no debugging. J\u00e1 o par\u00e2metro -g ir\u00e1 tornar dispon\u00edveis informa\u00e7\u00f5es \u00fateis para o debugging (como tipos de vari\u00e1veis e cabe\u00e7alhos das fun\u00e7\u00f5es) Question Abra o execut\u00e1vel com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Example O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Example Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Example Use o comando break funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Example Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta da Tarefa 2 e escreva abaixo suas novas conclus\u00f5es. Example O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Dicas : se a primeira instru\u00e7\u00e3o for endbr64 , execute stepi mais uma vez! use disas de novo verifique novamente o conte\u00fado de %edi Example Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Question Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? Example Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Example Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado no endere\u00e7o descoberto no exerc\u00edcio anterior. Confira seu resultado com o c\u00f3digo. Example Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine.","title":"Parando e continuando a execu\u00e7\u00e3o de um programa."},{"location":"aulas/03-arquitetura-x86/#enderecamento-relativo-e-variaveis-globais","text":"Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Example Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Example Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Question Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Question Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Question Anote abaixo o endere\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Desenho de acesso a mem\u00f3ria usando %rip A figura abaixo ilustra como funciona o endere\u00e7amento usando o registrador %rip . Note que os deslocamentos s\u00e3o diferentes pois o endere\u00e7o da instru\u00e7\u00e3o atual \u00e9 diferente. Por\u00e9m, o resultado final do endere\u00e7o calculado em ambas instru\u00e7\u00f5es \u00e9 o mesmo, indicando que ambas se referem ao mesmo local na mem\u00f3ria. Example Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Question Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Question Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf . Encontre ent\u00e3o o endere\u00e7o das strings de formata\u00e7\u00e3o e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"Endere\u00e7amento relativo e vari\u00e1veis globais"},{"location":"aulas/04-funcoes-mov/","text":"04 - Fun\u00e7\u00f5es \u00b6 Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos. Fun\u00e7\u00f5es e seus argumentos \u00b6 Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): long , unsigned long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C. Exemplo guiado \u00b6 Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq Assinatura da fun\u00e7\u00e3o \u00b6 Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long . O c\u00f3digo \u00b6 Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ). Pr\u00e1tica \u00b6 Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main . Arquivo ex1.o \u00b6 Question O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq Arquivo ex2.o \u00b6 Question Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Question Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C Arquivo ex3.o \u00b6 A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Question O qu\u00ea faz a instru\u00e7\u00e3o imul ? Question Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada. Arquivo ex4 \u00b6 Example Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Question Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Question Traduza a fun\u00e7\u00e3o ex4 para C . Arquivo ex5 (desafio) \u00b6 Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. A resposta dele ser\u00e1 validada nos atendimentos. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Question Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Question Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Question Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Question Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Question O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Question Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C .","title":"04 -  Fun\u00e7\u00f5es"},{"location":"aulas/04-funcoes-mov/#04-funcoes","text":"Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos.","title":"04 -  Fun\u00e7\u00f5es"},{"location":"aulas/04-funcoes-mov/#funcoes-e-seus-argumentos","text":"Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): long , unsigned long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C.","title":"Fun\u00e7\u00f5es e seus argumentos"},{"location":"aulas/04-funcoes-mov/#exemplo-guiado","text":"Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq","title":"Exemplo guiado"},{"location":"aulas/04-funcoes-mov/#assinatura-da-funcao","text":"Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long .","title":"Assinatura da fun\u00e7\u00e3o"},{"location":"aulas/04-funcoes-mov/#o-codigo","text":"Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ).","title":"O c\u00f3digo"},{"location":"aulas/04-funcoes-mov/#pratica","text":"Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main .","title":"Pr\u00e1tica"},{"location":"aulas/04-funcoes-mov/#arquivo-ex1o","text":"Question O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq","title":"Arquivo ex1.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex2o","text":"Question Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Question Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C","title":"Arquivo ex2.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex3o","text":"A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Question O qu\u00ea faz a instru\u00e7\u00e3o imul ? Question Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada.","title":"Arquivo ex3.o"},{"location":"aulas/04-funcoes-mov/#arquivo-ex4","text":"Example Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Question Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Question Traduza a fun\u00e7\u00e3o ex4 para C .","title":"Arquivo ex4"},{"location":"aulas/04-funcoes-mov/#arquivo-ex5-desafio","text":"Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. A resposta dele ser\u00e1 validada nos atendimentos. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Question Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Question Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Question Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Question Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Question O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Question Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C .","title":"Arquivo ex5 (desafio)"},{"location":"aulas/05-condicionais/","text":"05 - Condicionais \u00b6 Express\u00f5es booleanas \u00b6 Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da seguinte fun\u00e7\u00e3o: int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 em %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Mas antes, relembre da aula anterior a os registradores e a ordem em que os par\u00e2metros da fun\u00e7\u00e3o s\u00e3o passados: Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax . Registradores: Pronto! Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado. Arquivo ex1 \u00b6 Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex1 : 0 x0000000000000000 <+ 0 > : cmp $0xa , %edi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Question Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o em um arquivo .c . Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Tip Uma outra maneira de conferir se sua solu\u00e7\u00e3o est\u00e1 correta \u00e9 compilar e conferir no gdb se a sua solu\u00e7\u00e3o produz o mesmo ASM que o compilado disponibilizado pelo professor. Caso seu c\u00f3digo n\u00e3o possua fun\u00e7\u00e3o main, gere um .o utilizando a flag -c . Veja o Exemplo de compila\u00e7\u00e3o sem fun\u00e7\u00e3o main: $ gcc -Og -g -Wall -std = c99 -c ex_resposta.c -o ex1_resp.o Arquivo ex2 \u00b6 Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo Dump of assembler code for function ex2 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setbe %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Question Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Arquivo ex3 \u00b6 Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex3 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setg %dl 0 x000000000000000c <+ 12 > : and %edx , %eax 0 x000000000000000e <+ 14 > : movzbl %al , %eax 0 x0000000000000011 <+ 17 > : retq End of assembler dump. Question Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega. Condicionais \u00b6 Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais. Exemplo guiado \u00b6 Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . Question O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? Dica: Escreva o teste exato que a fun\u00e7\u00e3o faz. Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if ( a & 1 == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) { return 0 ; } return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples: Arquivo ex4 \u00b6 Veja o c\u00f3digo abaixo Dump of assembler code for function fun4 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : jle 0xf < fun4 + 15 > 0 x0000000000000005 <+ 5 > : mov $0x2 , %eax 0 x000000000000000a <+ 10 > : imul %rsi , %rax 0 x000000000000000e <+ 14 > : retq 0 x000000000000000f <+ 15 > : mov $0x1 , %eax 0 x0000000000000014 <+ 20 > : jmp 0xa < fun4 + 10 > End of assembler dump. Question Qual express\u00e3o booleana \u00e9 testada? Example Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Example Transforme o c\u00f3digo acima em C leg\u00edvel. Arquivo ex5 \u00b6 Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. Dump of assembler code for function ex5 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : setg %dl 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setle %al 0 x000000000000000c <+ 12 > : test %al , %dl 0 x000000000000000e <+ 14 > : jne 0x15 < ex5 + 21 > 0 x0000000000000010 <+ 16 > : lea -0 x2 ( %rsi ), %rax 0 x0000000000000014 <+ 20 > : retq 0 x0000000000000015 <+ 21 > : lea 0x5 ( %rdi ), %rax 0 x0000000000000019 <+ 25 > : retq End of assembler dump. Question Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Example Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Example Transforme seu c\u00f3digo acima para C leg\u00edvel. Exemplo guiado II \u00b6 Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio. Arquivo ex6 \u00b6 O exerc\u00edcio abaixo usa if-else . Dump of assembler code for function ex6 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : jle 0x8 < ex6 + 8 > 0 x0000000000000005 <+ 5 > : mov %rdi , %rsi 0 x0000000000000008 <+ 8 > : test %rdi , %rdi 0 x000000000000000b <+ 11 > : jle 0x10 < ex6 + 16 > 0 x000000000000000d <+ 13 > : neg %rsi 0 x0000000000000010 <+ 16 > : mov %esi , %eax 0 x0000000000000012 <+ 18 > : retq End of assembler dump. Example Traduza o c\u00f3digo acima para gotoC . Example Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"05 - Condicionais"},{"location":"aulas/05-condicionais/#05-condicionais","text":"","title":"05 - Condicionais"},{"location":"aulas/05-condicionais/#expressoes-booleanas","text":"Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da seguinte fun\u00e7\u00e3o: int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 em %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Mas antes, relembre da aula anterior a os registradores e a ordem em que os par\u00e2metros da fun\u00e7\u00e3o s\u00e3o passados: Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores ( nesta ordem ): %rdi %rsi %rdx %rcx %r8 %r9 Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax . Registradores: Pronto! Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado.","title":"Express\u00f5es booleanas"},{"location":"aulas/05-condicionais/#arquivo-ex1","text":"Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex1 : 0 x0000000000000000 <+ 0 > : cmp $0xa , %edi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Question Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o em um arquivo .c . Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Tip Uma outra maneira de conferir se sua solu\u00e7\u00e3o est\u00e1 correta \u00e9 compilar e conferir no gdb se a sua solu\u00e7\u00e3o produz o mesmo ASM que o compilado disponibilizado pelo professor. Caso seu c\u00f3digo n\u00e3o possua fun\u00e7\u00e3o main, gere um .o utilizando a flag -c . Veja o Exemplo de compila\u00e7\u00e3o sem fun\u00e7\u00e3o main: $ gcc -Og -g -Wall -std = c99 -c ex_resposta.c -o ex1_resp.o","title":"Arquivo ex1"},{"location":"aulas/05-condicionais/#arquivo-ex2","text":"Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo Dump of assembler code for function ex2 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setbe %al 0 x0000000000000006 <+ 6 > : movzbl %al , %eax 0 x0000000000000009 <+ 9 > : retq End of assembler dump. Question Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o.","title":"Arquivo ex2"},{"location":"aulas/05-condicionais/#arquivo-ex3","text":"Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. Dump of assembler code for function ex3 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : setg %al 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setg %dl 0 x000000000000000c <+ 12 > : and %edx , %eax 0 x000000000000000e <+ 14 > : movzbl %al , %eax 0 x0000000000000011 <+ 17 > : retq End of assembler dump. Question Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega.","title":"Arquivo ex3"},{"location":"aulas/05-condicionais/#condicionais","text":"Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais.","title":"Condicionais"},{"location":"aulas/05-condicionais/#exemplo-guiado","text":"Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . Question O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? Dica: Escreva o teste exato que a fun\u00e7\u00e3o faz. Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if ( a & 1 == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) { return 0 ; } return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples:","title":"Exemplo guiado"},{"location":"aulas/05-condicionais/#arquivo-ex4","text":"Veja o c\u00f3digo abaixo Dump of assembler code for function fun4 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : jle 0xf < fun4 + 15 > 0 x0000000000000005 <+ 5 > : mov $0x2 , %eax 0 x000000000000000a <+ 10 > : imul %rsi , %rax 0 x000000000000000e <+ 14 > : retq 0 x000000000000000f <+ 15 > : mov $0x1 , %eax 0 x0000000000000014 <+ 20 > : jmp 0xa < fun4 + 10 > End of assembler dump. Question Qual express\u00e3o booleana \u00e9 testada? Example Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Example Transforme o c\u00f3digo acima em C leg\u00edvel.","title":"Arquivo ex4"},{"location":"aulas/05-condicionais/#arquivo-ex5","text":"Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. Dump of assembler code for function ex5 : 0 x0000000000000000 <+ 0 > : test %rdi , %rdi 0 x0000000000000003 <+ 3 > : setg %dl 0 x0000000000000006 <+ 6 > : test %rsi , %rsi 0 x0000000000000009 <+ 9 > : setle %al 0 x000000000000000c <+ 12 > : test %al , %dl 0 x000000000000000e <+ 14 > : jne 0x15 < ex5 + 21 > 0 x0000000000000010 <+ 16 > : lea -0 x2 ( %rsi ), %rax 0 x0000000000000014 <+ 20 > : retq 0 x0000000000000015 <+ 21 > : lea 0x5 ( %rdi ), %rax 0 x0000000000000019 <+ 25 > : retq End of assembler dump. Question Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Example Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Example Transforme seu c\u00f3digo acima para C leg\u00edvel.","title":"Arquivo ex5"},{"location":"aulas/05-condicionais/#exemplo-guiado-ii","text":"Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio.","title":"Exemplo guiado II"},{"location":"aulas/05-condicionais/#arquivo-ex6","text":"O exerc\u00edcio abaixo usa if-else . Dump of assembler code for function ex6 : 0 x0000000000000000 <+ 0 > : cmp %rsi , %rdi 0 x0000000000000003 <+ 3 > : jle 0x8 < ex6 + 8 > 0 x0000000000000005 <+ 5 > : mov %rdi , %rsi 0 x0000000000000008 <+ 8 > : test %rdi , %rdi 0 x000000000000000b <+ 11 > : jle 0x10 < ex6 + 16 > 0 x000000000000000d <+ 13 > : neg %rsi 0 x0000000000000010 <+ 16 > : mov %esi , %eax 0 x0000000000000012 <+ 18 > : retq End of assembler dump. Example Traduza o c\u00f3digo acima para gotoC . Example Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"Arquivo ex6"},{"location":"aulas/06-condicionais-funcoes/","text":"06 - Condicionais e fun\u00e7\u00f5es \u00b6 Na aula de hoje vamos revisar e praticar os conceitos de fun\u00e7\u00f5es e condicionais em Assembly. Teremos exerc\u00edcios simples de cada assunto e no fim alguns exerc\u00edcios para entrega que juntam coisas diferentes. Fun\u00e7\u00f5es e aritm\u00e9tica com LEA \u00b6 Todos os exerc\u00edcios da revis\u00e3o ser\u00e3o feitos com o arquivo exemplo1 (compilado a partir de exemplo1.c ). Vamos examinar tanto a fun\u00e7\u00e3o main quanto a fun\u00e7\u00e3o exemplo1 . Compile com: $ gcc -Og -Wall -std = c99 exemplo1.c -o exemplo1 Chamadas de fun\u00e7\u00f5es \u00b6 As chamadas de fun\u00e7\u00e3o s\u00e3o feitas usando a seguinte ordem para os argumentos inteiros: %rdi %rsi %rdx %rcx %r8 %r9 Esta ordem nunca muda . Veja abaixo um exemplo de chamada de fun\u00e7\u00e3o tirado do main de exemplo1 . 0 x065c <+ 4 > : mov $0x6 , %r9d 0 x0662 <+ 10 > : mov $0x5 , %r8d 0 x0668 <+ 16 > : mov $0x4 , %ecx 0 x066d <+ 21 > : mov $0x3 , %edx 0 x0672 <+ 26 > : mov $0x2 , %esi 0 x0677 <+ 31 > : mov $0x1 , %edi 0 x067c <+ 36 > : callq 0x64a < exemplo1 > 0 x0681 <+ 41 > : lea 0xa ( %rax ), %esi Pergunta O valor do primeiro argumento da fun\u00e7\u00e3o \u00e9 6 1 Answer A ordem dos par\u00e2metros segue \u00e9 sempre a mesma vista na aula 04 . Mesmo que as instru\u00e7\u00f5es estejam em ordem diferente, %edi (ou uma de suas partes) \u00e9 sempre o primeiro par\u00e2metro. Exercise A instru\u00e7\u00e3o call realiza chamadas de fun\u00e7\u00e3o. Traduza a chamada de fun\u00e7\u00e3o acima para C . Answer exemplo1(1, 2, 3, 4, 5, 6) Vamos agora analisar o c\u00f3digo de exemplo1 : Dump of assembler code for function exemplo1 : 0 x064a <+ 0 > : add %esi , %edi 0 x064c <+ 2 > : add %edi , %edx 0 x064e <+ 4 > : add %edx , %ecx 0 x0650 <+ 6 > : add %r8d , %ecx 0 x0653 <+ 9 > : lea ( %rcx , %r9 , 1 ), %eax 0 x0657 <+ 13 > : retq Exercise Quantos par\u00e2metros a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Ela retorna algum valor? Se sim, qual seu tipo? Answer S\u00e3o seis par\u00e2metros, todos int Exercise Declare a fun\u00e7\u00e3o acima com base na sua resposta anterior. Answer int exemplo1(int a, int b, int c, int d, int e, int f); Exercise O que faz o conjunto de instru\u00e7\u00f5es add nas linhas +0 at\u00e9 +6 ? Escreva uma express\u00e3o em C equivalente. Answer Ela soma os primeiros 5 argumentos: a + b + c + e . Vemos na linha exemplo1+9 que colocamos um valor no registrador %eax e depois finalizamos a fun\u00e7\u00e3o usando retq . Este \u00e9 o segundo ponto que nunca muda: o valor de retorno de toda fun\u00e7\u00e3o \u00e9 colocado no registrador %rax (ou uma de suas partes menores). Neste exemplo, a instru\u00e7\u00e3o usada foi o LEA que veremos na se\u00e7\u00e3o a seguir. Opera\u00e7\u00f5es aritm\u00e9ticas usando LEA \u00b6 Se usada de maneira literal, a instru\u00e7\u00e3o LEA (**L**oad **E**ffective **A**ddress) serve para calcular o endere\u00e7o de uma vari\u00e1vel local e \u00e9 equivalente ao operador & em C . Por\u00e9m, ela \u00e9 frequentemente \"abusada\" para fazer aritm\u00e9tica. Um ponto importante quando usamos LEA \u00e9 que todos os operandos s\u00e3o registradores de 64 bits. Regra geral Se LEA for usada com o registrador %rsp ent\u00e3o ela sempre representa o operador & Se os registradores envolvidos foram usados como n\u00fameros inteiros em instru\u00e7\u00f5es anteriores, ent\u00e3o ela representa uma conta com os valores dos registradores. Vejamos o exemplo da fun\u00e7\u00e3o exemplo1 acima: 0 x0653 <+ 9 > : lea ( %rcx , %r9 , 1 ), %eax No exemplo acima LEA \u00e9 usada para fazer aritm\u00e9tica. Sabemos disso pois, na chamada traduzida na parte anterior, elas recebem n\u00fameros inteiros ( %r9d = 6 e %ecx = 4 ). Seu primeiro argumento segue a seguinte l\u00f3gica C ( %R1 , %R2 , S ) C \u00e9 uma constante %R1 \u00e9 um registrador %R2 \u00e9 um registrador (pode ser igual a %R1 ) S \u00e9 1, 2, 4 ou 8 (todos os tamanhos poss\u00edveis de registradores inteiros) A opera\u00e7\u00e3o acima calcula C + %R1 + (%R2 * S) . A opera\u00e7\u00e3o LEA nunca acessa a mem\u00f3ria , apenas move o resultado deste c\u00e1lculo para o registrador destino. Qualquer outra opera\u00e7\u00e3o que use a sintaxa acima est\u00e1 fazendo um acesso a mem\u00f3ria. LEA \u00e9 a \u00fanica exce\u00e7\u00e3o! Exercise Traduza a opera\u00e7\u00e3o abaixo para C 0 x0653 <+ 9 > : lea ( %rcx , %r9 , 1 ), %eax Exercise Com estas informa\u00e7\u00f5es em m\u00e3os, traduza exemplo1 para C Dump of assembler code for function exemplo1 : 0 x064a <+ 0 > : add %esi , %edi 0 x064c <+ 2 > : add %edi , %edx 0 x064e <+ 4 > : add %edx , %ecx 0 x0650 <+ 6 > : add %r8d , %ecx 0 x0653 <+ 9 > : lea ( %rcx , %r9 , 1 ), %eax 0 x0657 <+ 13 > : retq Answer Confira no arquivo exemplo1.c Retorno de fun\u00e7\u00f5es \u00b6 Vamos terminar nossa revis\u00e3o analisando novamente a chamada de exemplo1 no main : 0 x065c <+ 4 > : mov $0x6 , %r9d 0 x0662 <+ 10 > : mov $0x5 , %r8d 0 x0668 <+ 16 > : mov $0x4 , %ecx 0 x066d <+ 21 > : mov $0x3 , %edx 0 x0672 <+ 26 > : mov $0x2 , %esi 0 x0677 <+ 31 > : mov $0x1 , %edi 0 x067c <+ 36 > : callq 0x64a < exemplo1 > 0 x0681 <+ 41 > : lea 0xa ( %rax ), %esi Anteriormente j\u00e1 vimos que o call e os mov s acima fazem a chamada exemplo1(1,2,3,4,5,6) em C . A linha de baixo realiza uma opera\u00e7\u00e3o aritm\u00e9tica com %rax . Exercise Considerando que %rax armazena o valor de retorno de uma fun\u00e7\u00e3o, qual seria a tradu\u00e7\u00e3o para C do bloco de c\u00f3digo acima? Answer int esi = exemplo1(1, 2, 3, 4, 5, 6) + 10; Exerc\u00edcios combinados \u00b6 Warning Todos os exerc\u00edcios desta se\u00e7\u00e3o s\u00e3o para entrega. Voc\u00eas podem se conversar para faz\u00ea-los, mas cada um deve criar sua pr\u00f3pria solu\u00e7\u00e3o do zero. Todos os exerc\u00edcios j\u00e1 est\u00e3o dispon\u00edveis no seu reposit\u00f3rio de entregas da disciplina em atv/03-condicionais-funcoes . Leia o README dentro da pasta para mais informa\u00e7\u00f5es. ex1 : Aritm\u00e9tica e Express\u00f5es booleanas . \u00b6 Dump of assembler code for function ex1 : 0 x05fa <+ 0 > : lea ( %rdi , %rsi , 1 ), %rax 0 x05fe <+ 4 > : lea ( %rax , %rdx , 4 ), %rcx 0 x0602 <+ 8 > : imul %rdi , %rdi 0 x0606 <+ 12 > : lea ( %rdi , %rsi , 2 ), %rax 0 x060a <+ 16 > : add %rax , %rdx 0 x060d <+ 19 > : cmp %rdx , %rcx 0 x0610 <+ 22 > : setge %al 0 x0613 <+ 25 > : movzbl %al , %eax 0 x0616 <+ 28 > : retq Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Declare a fun\u00e7\u00e3o abaixo. Exercise As instru\u00e7\u00f5es LEA acima representam opera\u00e7\u00f5es aritm\u00e9ticas ou a opera\u00e7\u00e3o endere\u00e7o de & ? Como voc\u00ea fez esta identifica\u00e7\u00e3o? . Exercise Traduza as opera\u00e7\u00f5es das linhas ex1+0 at\u00e9 ex1+12 para C Exercise Nas linhas ex1+19 e ex1+22 \u00e9 feita uma compara\u00e7\u00e3o. Qual e entre quais registradores? Onde \u00e9 armazenado este resultado? Exercise O qu\u00ea faz a instru\u00e7\u00e3o movzbl em ex1+25 ? Juntando com a resposta da pergunta acima, traduza as instru\u00e7\u00f5es ex1+19 at\u00e9 ex1+28 para C . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes. ex2 : Chamadas de fun\u00e7\u00f5es e Condicionais . \u00b6 Quando analisar o c\u00f3digo do ex2 no gdb, utilize o arquivo ex2_ref para visualizar corretamente as chamadas de fun\u00e7\u00f5es. Dump of assembler code for function ex2 : 0 x05ff <+ 0 > : push %rbx 0 x0600 <+ 1 > : mov %rdi , %rbx 0 x0603 <+ 4 > : mov %rsi , %rdi 0 x0606 <+ 7 > : callq 0x5fa < vezes2 > 0 x060b <+ 12 > : cmp %rbx , %rax 0 x060e <+ 15 > : jle 0x613 < ex2 + 20 > 0 x0610 <+ 17 > : add %rbx , %rbx 0 x0613 <+ 20 > : add %rbx , %rax 0 x0616 <+ 23 > : pop %rbx 0 x0617 <+ 24 > : retq Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais s\u00e3o seus tipos? Declare-a abaixo. Vamos come\u00e7ar trabalhando na linha ex2+7 , na instru\u00e7\u00e3o call vezes2 . A chamada necessita usar o registrador %rdi , mas ele cont\u00e9m o primeiro argumento de ex2 . Exercise Em qual registrador \u00e9 guardado o primeiro argumento de ex2 ? Isso \u00e9 feito antes da chamada call . Exercise Qual vari\u00e1vel \u00e9 passada como argumento para a fun\u00e7\u00e3o vezes2 ? Exercise Escreva abaixo a invoca\u00e7\u00e3o de vezes2 . Voc\u00ea deve ter notado as instru\u00e7\u00f5es push/pop %rbx no come\u00e7o/fim da fun\u00e7\u00e3o. Toda fun\u00e7\u00e3o pode usar os registradores de argumentos (vistos na parte 1) e o de valor de retorno como quiserem. Se precisarem mexer nos outros registradores a pr\u00e1tica \u00e9 salv\u00e1-los na pilha no come\u00e7o da fun\u00e7\u00e3o e restaur\u00e1-los no fim. Assim n\u00e3o importa o que a fun\u00e7\u00e3o fa\u00e7a, para a fun\u00e7\u00e3o chamadora \u00e9 como se n\u00e3o houvesse havido nenhuma modifica\u00e7\u00e3o nos outros registradores. Vamos agora olhar a condicional na linha ex2+12 . Exercise Ap\u00f3s a chamada call , qual o conte\u00fado de %rax ? Exercise Juntando suas respostas nas quest\u00f5es de cima, qual \u00e9 a compara\u00e7\u00e3o feita nas linhas ex2+12, ex2+15 ? Exercise Com essas informa\u00e7\u00f5es em m\u00e3os, fa\u00e7a uma tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if+goto . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes. ex3 : Ponteiros e Express\u00f5es booleanas . \u00b6 Dump of assembler code for function ex3 : 0 x0000000000000000 <+ 0 > : endbr64 0x0000000000000004 <+ 4 > : cmp %rsi , %rdi 0 x0000000000000007 <+ 7 > : setl %al 0 x000000000000000a <+ 10 > : movzbl %al , %eax 0 x000000000000000d <+ 13 > : mov %eax ,( %rdx ) 0 x000000000000000f <+ 15 > : sete %al 0 x0000000000000012 <+ 18 > : movzbl %al , %eax 0 x0000000000000015 <+ 21 > : mov %eax ,( %rcx ) 0 x0000000000000017 <+ 23 > : setg %al 0 x000000000000001a <+ 26 > : movzbl %al , %eax 0 x000000000000001d <+ 29 > : mov %eax ,( %r8 ) 0 x0000000000000020 <+ 32 > : retq Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"06 - Condicionais e fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#06-condicionais-e-funcoes","text":"Na aula de hoje vamos revisar e praticar os conceitos de fun\u00e7\u00f5es e condicionais em Assembly. Teremos exerc\u00edcios simples de cada assunto e no fim alguns exerc\u00edcios para entrega que juntam coisas diferentes.","title":"06 - Condicionais e fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#funcoes-e-aritmetica-com-lea","text":"Todos os exerc\u00edcios da revis\u00e3o ser\u00e3o feitos com o arquivo exemplo1 (compilado a partir de exemplo1.c ). Vamos examinar tanto a fun\u00e7\u00e3o main quanto a fun\u00e7\u00e3o exemplo1 . Compile com: $ gcc -Og -Wall -std = c99 exemplo1.c -o exemplo1","title":"Fun\u00e7\u00f5es e aritm\u00e9tica com LEA"},{"location":"aulas/06-condicionais-funcoes/#chamadas-de-funcoes","text":"As chamadas de fun\u00e7\u00e3o s\u00e3o feitas usando a seguinte ordem para os argumentos inteiros: %rdi %rsi %rdx %rcx %r8 %r9 Esta ordem nunca muda . Veja abaixo um exemplo de chamada de fun\u00e7\u00e3o tirado do main de exemplo1 . 0 x065c <+ 4 > : mov $0x6 , %r9d 0 x0662 <+ 10 > : mov $0x5 , %r8d 0 x0668 <+ 16 > : mov $0x4 , %ecx 0 x066d <+ 21 > : mov $0x3 , %edx 0 x0672 <+ 26 > : mov $0x2 , %esi 0 x0677 <+ 31 > : mov $0x1 , %edi 0 x067c <+ 36 > : callq 0x64a < exemplo1 > 0 x0681 <+ 41 > : lea 0xa ( %rax ), %esi Pergunta O valor do primeiro argumento da fun\u00e7\u00e3o \u00e9 6 1 Answer A ordem dos par\u00e2metros segue \u00e9 sempre a mesma vista na aula 04 . Mesmo que as instru\u00e7\u00f5es estejam em ordem diferente, %edi (ou uma de suas partes) \u00e9 sempre o primeiro par\u00e2metro. Exercise A instru\u00e7\u00e3o call realiza chamadas de fun\u00e7\u00e3o. Traduza a chamada de fun\u00e7\u00e3o acima para C . Answer exemplo1(1, 2, 3, 4, 5, 6) Vamos agora analisar o c\u00f3digo de exemplo1 : Dump of assembler code for function exemplo1 : 0 x064a <+ 0 > : add %esi , %edi 0 x064c <+ 2 > : add %edi , %edx 0 x064e <+ 4 > : add %edx , %ecx 0 x0650 <+ 6 > : add %r8d , %ecx 0 x0653 <+ 9 > : lea ( %rcx , %r9 , 1 ), %eax 0 x0657 <+ 13 > : retq Exercise Quantos par\u00e2metros a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Ela retorna algum valor? Se sim, qual seu tipo? Answer S\u00e3o seis par\u00e2metros, todos int Exercise Declare a fun\u00e7\u00e3o acima com base na sua resposta anterior. Answer int exemplo1(int a, int b, int c, int d, int e, int f); Exercise O que faz o conjunto de instru\u00e7\u00f5es add nas linhas +0 at\u00e9 +6 ? Escreva uma express\u00e3o em C equivalente. Answer Ela soma os primeiros 5 argumentos: a + b + c + e . Vemos na linha exemplo1+9 que colocamos um valor no registrador %eax e depois finalizamos a fun\u00e7\u00e3o usando retq . Este \u00e9 o segundo ponto que nunca muda: o valor de retorno de toda fun\u00e7\u00e3o \u00e9 colocado no registrador %rax (ou uma de suas partes menores). Neste exemplo, a instru\u00e7\u00e3o usada foi o LEA que veremos na se\u00e7\u00e3o a seguir.","title":"Chamadas de fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#operacoes-aritmeticas-usando-lea","text":"Se usada de maneira literal, a instru\u00e7\u00e3o LEA (**L**oad **E**ffective **A**ddress) serve para calcular o endere\u00e7o de uma vari\u00e1vel local e \u00e9 equivalente ao operador & em C . Por\u00e9m, ela \u00e9 frequentemente \"abusada\" para fazer aritm\u00e9tica. Um ponto importante quando usamos LEA \u00e9 que todos os operandos s\u00e3o registradores de 64 bits. Regra geral Se LEA for usada com o registrador %rsp ent\u00e3o ela sempre representa o operador & Se os registradores envolvidos foram usados como n\u00fameros inteiros em instru\u00e7\u00f5es anteriores, ent\u00e3o ela representa uma conta com os valores dos registradores. Vejamos o exemplo da fun\u00e7\u00e3o exemplo1 acima: 0 x0653 <+ 9 > : lea ( %rcx , %r9 , 1 ), %eax No exemplo acima LEA \u00e9 usada para fazer aritm\u00e9tica. Sabemos disso pois, na chamada traduzida na parte anterior, elas recebem n\u00fameros inteiros ( %r9d = 6 e %ecx = 4 ). Seu primeiro argumento segue a seguinte l\u00f3gica C ( %R1 , %R2 , S ) C \u00e9 uma constante %R1 \u00e9 um registrador %R2 \u00e9 um registrador (pode ser igual a %R1 ) S \u00e9 1, 2, 4 ou 8 (todos os tamanhos poss\u00edveis de registradores inteiros) A opera\u00e7\u00e3o acima calcula C + %R1 + (%R2 * S) . A opera\u00e7\u00e3o LEA nunca acessa a mem\u00f3ria , apenas move o resultado deste c\u00e1lculo para o registrador destino. Qualquer outra opera\u00e7\u00e3o que use a sintaxa acima est\u00e1 fazendo um acesso a mem\u00f3ria. LEA \u00e9 a \u00fanica exce\u00e7\u00e3o! Exercise Traduza a opera\u00e7\u00e3o abaixo para C 0 x0653 <+ 9 > : lea ( %rcx , %r9 , 1 ), %eax Exercise Com estas informa\u00e7\u00f5es em m\u00e3os, traduza exemplo1 para C Dump of assembler code for function exemplo1 : 0 x064a <+ 0 > : add %esi , %edi 0 x064c <+ 2 > : add %edi , %edx 0 x064e <+ 4 > : add %edx , %ecx 0 x0650 <+ 6 > : add %r8d , %ecx 0 x0653 <+ 9 > : lea ( %rcx , %r9 , 1 ), %eax 0 x0657 <+ 13 > : retq Answer Confira no arquivo exemplo1.c","title":"Opera\u00e7\u00f5es aritm\u00e9ticas usando LEA"},{"location":"aulas/06-condicionais-funcoes/#retorno-de-funcoes","text":"Vamos terminar nossa revis\u00e3o analisando novamente a chamada de exemplo1 no main : 0 x065c <+ 4 > : mov $0x6 , %r9d 0 x0662 <+ 10 > : mov $0x5 , %r8d 0 x0668 <+ 16 > : mov $0x4 , %ecx 0 x066d <+ 21 > : mov $0x3 , %edx 0 x0672 <+ 26 > : mov $0x2 , %esi 0 x0677 <+ 31 > : mov $0x1 , %edi 0 x067c <+ 36 > : callq 0x64a < exemplo1 > 0 x0681 <+ 41 > : lea 0xa ( %rax ), %esi Anteriormente j\u00e1 vimos que o call e os mov s acima fazem a chamada exemplo1(1,2,3,4,5,6) em C . A linha de baixo realiza uma opera\u00e7\u00e3o aritm\u00e9tica com %rax . Exercise Considerando que %rax armazena o valor de retorno de uma fun\u00e7\u00e3o, qual seria a tradu\u00e7\u00e3o para C do bloco de c\u00f3digo acima? Answer int esi = exemplo1(1, 2, 3, 4, 5, 6) + 10;","title":"Retorno de fun\u00e7\u00f5es"},{"location":"aulas/06-condicionais-funcoes/#exercicios-combinados","text":"Warning Todos os exerc\u00edcios desta se\u00e7\u00e3o s\u00e3o para entrega. Voc\u00eas podem se conversar para faz\u00ea-los, mas cada um deve criar sua pr\u00f3pria solu\u00e7\u00e3o do zero. Todos os exerc\u00edcios j\u00e1 est\u00e3o dispon\u00edveis no seu reposit\u00f3rio de entregas da disciplina em atv/03-condicionais-funcoes . Leia o README dentro da pasta para mais informa\u00e7\u00f5es.","title":"Exerc\u00edcios combinados"},{"location":"aulas/06-condicionais-funcoes/#ex1-aritmetica-e-expressoes-booleanas","text":"Dump of assembler code for function ex1 : 0 x05fa <+ 0 > : lea ( %rdi , %rsi , 1 ), %rax 0 x05fe <+ 4 > : lea ( %rax , %rdx , 4 ), %rcx 0 x0602 <+ 8 > : imul %rdi , %rdi 0 x0606 <+ 12 > : lea ( %rdi , %rsi , 2 ), %rax 0 x060a <+ 16 > : add %rax , %rdx 0 x060d <+ 19 > : cmp %rdx , %rcx 0 x0610 <+ 22 > : setge %al 0 x0613 <+ 25 > : movzbl %al , %eax 0 x0616 <+ 28 > : retq Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Declare a fun\u00e7\u00e3o abaixo. Exercise As instru\u00e7\u00f5es LEA acima representam opera\u00e7\u00f5es aritm\u00e9ticas ou a opera\u00e7\u00e3o endere\u00e7o de & ? Como voc\u00ea fez esta identifica\u00e7\u00e3o? . Exercise Traduza as opera\u00e7\u00f5es das linhas ex1+0 at\u00e9 ex1+12 para C Exercise Nas linhas ex1+19 e ex1+22 \u00e9 feita uma compara\u00e7\u00e3o. Qual e entre quais registradores? Onde \u00e9 armazenado este resultado? Exercise O qu\u00ea faz a instru\u00e7\u00e3o movzbl em ex1+25 ? Juntando com a resposta da pergunta acima, traduza as instru\u00e7\u00f5es ex1+19 at\u00e9 ex1+28 para C . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"ex1: Aritm\u00e9tica e Express\u00f5es booleanas."},{"location":"aulas/06-condicionais-funcoes/#ex2-chamadas-de-funcoes-e-condicionais","text":"Quando analisar o c\u00f3digo do ex2 no gdb, utilize o arquivo ex2_ref para visualizar corretamente as chamadas de fun\u00e7\u00f5es. Dump of assembler code for function ex2 : 0 x05ff <+ 0 > : push %rbx 0 x0600 <+ 1 > : mov %rdi , %rbx 0 x0603 <+ 4 > : mov %rsi , %rdi 0 x0606 <+ 7 > : callq 0x5fa < vezes2 > 0 x060b <+ 12 > : cmp %rbx , %rax 0 x060e <+ 15 > : jle 0x613 < ex2 + 20 > 0 x0610 <+ 17 > : add %rbx , %rbx 0 x0613 <+ 20 > : add %rbx , %rax 0 x0616 <+ 23 > : pop %rbx 0 x0617 <+ 24 > : retq Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais s\u00e3o seus tipos? Declare-a abaixo. Vamos come\u00e7ar trabalhando na linha ex2+7 , na instru\u00e7\u00e3o call vezes2 . A chamada necessita usar o registrador %rdi , mas ele cont\u00e9m o primeiro argumento de ex2 . Exercise Em qual registrador \u00e9 guardado o primeiro argumento de ex2 ? Isso \u00e9 feito antes da chamada call . Exercise Qual vari\u00e1vel \u00e9 passada como argumento para a fun\u00e7\u00e3o vezes2 ? Exercise Escreva abaixo a invoca\u00e7\u00e3o de vezes2 . Voc\u00ea deve ter notado as instru\u00e7\u00f5es push/pop %rbx no come\u00e7o/fim da fun\u00e7\u00e3o. Toda fun\u00e7\u00e3o pode usar os registradores de argumentos (vistos na parte 1) e o de valor de retorno como quiserem. Se precisarem mexer nos outros registradores a pr\u00e1tica \u00e9 salv\u00e1-los na pilha no come\u00e7o da fun\u00e7\u00e3o e restaur\u00e1-los no fim. Assim n\u00e3o importa o que a fun\u00e7\u00e3o fa\u00e7a, para a fun\u00e7\u00e3o chamadora \u00e9 como se n\u00e3o houvesse havido nenhuma modifica\u00e7\u00e3o nos outros registradores. Vamos agora olhar a condicional na linha ex2+12 . Exercise Ap\u00f3s a chamada call , qual o conte\u00fado de %rax ? Exercise Juntando suas respostas nas quest\u00f5es de cima, qual \u00e9 a compara\u00e7\u00e3o feita nas linhas ex2+12, ex2+15 ? Exercise Com essas informa\u00e7\u00f5es em m\u00e3os, fa\u00e7a uma tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if+goto . Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"ex2: Chamadas de fun\u00e7\u00f5es e Condicionais."},{"location":"aulas/06-condicionais-funcoes/#ex3-ponteiros-e-expressoes-booleanas","text":"Dump of assembler code for function ex3 : 0 x0000000000000000 <+ 0 > : endbr64 0x0000000000000004 <+ 4 > : cmp %rsi , %rdi 0 x0000000000000007 <+ 7 > : setl %al 0 x000000000000000a <+ 10 > : movzbl %al , %eax 0 x000000000000000d <+ 13 > : mov %eax ,( %rdx ) 0 x000000000000000f <+ 15 > : sete %al 0 x0000000000000012 <+ 18 > : movzbl %al , %eax 0 x0000000000000015 <+ 21 > : mov %eax ,( %rcx ) 0 x0000000000000017 <+ 23 > : setg %al 0 x000000000000001a <+ 26 > : movzbl %al , %eax 0 x000000000000001d <+ 29 > : mov %eax ,( %r8 ) 0 x0000000000000020 <+ 32 > : retq Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? De quais tipos? Declare-a abaixo. Exercise A fun\u00e7\u00e3o acima faz v\u00e1rias compara\u00e7\u00f5es. Liste quais e entre quais argumentos. Exercise Onde \u00e9 armazenado o resultado de cada compara\u00e7\u00e3o? Exercise Com base em suas respostas acima, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha da fun\u00e7\u00e3o acima. Example Usando as perguntas acima preencha o arquivo de solu\u00e7\u00e3o no reposit\u00f3rio e execute os testes.","title":"ex3: Ponteiros e Express\u00f5es booleanas."},{"location":"aulas/07-loops/","text":"07 - Loops \u00b6 Arquivo ex1 \u00b6 Utilize como base o c\u00f3digo assembly abaixo (arquivo ex1 ) e responda os itens. Dump of assembler code for function soma_2n : 0 x066a <+ 0 > : mov $0x1 , %eax 0 x066f <+ 5 > : jmp 0x676 < soma_2n + 12 > 0 x0671 <+ 7 > : shr %edi 0 x0673 <+ 9 > : add $0x1 , %eax 0 x0676 <+ 12 > : cmp $0x1 , %edi 0 x0679 <+ 15 > : ja 0x671 < soma_2n + 7 > 0 x067b <+ 17 > : repz retq Exercise Localize no c\u00f3digo acima as instru\u00e7\u00f5es de saltos ( jmp ou condicionais j* ). Desenhe setas indicando para qual linha do c\u00f3digo elas pulam. Answer H\u00e1 um salto de soma_2n <+5> para soma_2n <+12> e outro de soma_2n <+15> para soma_2n <+7> Exercise Analise o fluxo de saltos do seu c\u00f3digo. Existe um loop? Entre quais linhas? Answer O loop ocorre entre as linhas +5 e +15 . Exercise Qual \u00e9 a condi\u00e7\u00e3o do loop acima? Ou seja, qual condi\u00e7\u00e3o precisa ser verdade para que o loop continue rodando ? %edi > 1 %edi < 1 %edi > 0 %eax > 1 Answer Sempre comparamos o segundo em rela\u00e7\u00e3o ao primeiro. Logo, fazemos %edi > 1 . A instru\u00e7\u00e3o ja representa a compara\u00e7\u00e3o jump above , que \u00e9 uma compara\u00e7\u00e3o de > feita entre vari\u00e1veis unsigned Exercise Com base na sua resposta acima, como voc\u00ea escreveria esse loop como um while ? Answer Considerando que o primeiro argumento da fun\u00e7\u00e3o se chama int arg1 , seria while(arg1 > 1) . Exercise Comece fazendo uma vers\u00e3o C usando somente if-goto Answer int soma_2n ( unsigned int a ) { int res = 1 ; goto verifica ; faz_algo : a = a >> 1 ; res += 1 ; verifica : if ( a > 1 ) { goto faz_algo ; } return res ; } Exercise Transforme a constru\u00e7\u00e3o que voc\u00ea fez acima em um c\u00f3digo usando while . Answer int soma_2n ( unsigned int a ) { int res = 1 ; while ( a > 1 ) { a = a / 2 ; res ++ ; } return res ; } Exerc\u00edcios para entrega \u00b6 Vamos agora exercitar o que vimos na aula expositiva. Os exerc\u00edcios abaixo est\u00e3o no reposit\u00f3rio de atividades e as perguntas no handout tem o objetivo de ajudar a compreender c\u00f3digos cada vez mais complexos. Arquivo ex2 \u00b6 Leia o c\u00f3digo assembly abaixo e responda. Dump of assembler code for function soma_n : 0 x066a <+ 0 > : mov $0x0 , %edx 0 x066f <+ 5 > : mov $0x0 , %eax 0 x0674 <+ 10 > : jmp 0x67f < soma_n + 21 > 0 x0676 <+ 12 > : movslq %edx , %rcx 0 x0679 <+ 15 > : add %rcx , %rax 0 x067c <+ 18 > : add $0x1 , %edx 0 x067f <+ 21 > : cmp %edi , %edx 0 x0681 <+ 23 > : jl 0x676 < soma_n + 12 > 0 x0683 <+ 25 > : repz retq Exercise Desenhe as flechas indicando o destino de cada instru\u00e7\u00e3o de pulo ( jmp ou j* ). Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva abaixo o cabe\u00e7alho da fun\u00e7\u00e3o soma_n . Dica : procure por registradores que s\u00e3o lidos antes de serem escritos. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Fa\u00e7a a tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if-goto Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Converta o c\u00f3digo acima para uma vers\u00e3o leg\u00edvel em C . Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Arquivo ex3 \u00b6 Dump of assembler code for function ex3 : 0 x1139 <+ 0 > : mov $0x0 , %ecx 0 x113e <+ 5 > : mov $0x0 , %r8d 0 x1144 <+ 11 > : jmp 0x114a < ex4 + 17 > 0 x1146 <+ 13 > : add $0x1 , %rcx 0 x114a <+ 17 > : cmp %rdi , %rcx 0 x114d <+ 20 > : jge 0x1161 < ex4 + 40 > 0 x114f <+ 22 > : mov %rcx , %rax 0 x1152 <+ 25 > : cqto 0 x1154 <+ 27 > : idiv %rsi 0 x1157 <+ 30 > : test %rdx , %rdx 0 x115a <+ 33 > : jne 0x1146 < ex4 + 13 > 0 x115c <+ 35 > : add %rcx , %r8 0 x115f <+ 38 > : jmp 0x1146 < ex4 + 13 > 0 x1161 <+ 40 > : mov %r8 , %rax 0 x1164 <+ 43 > : retq Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Dica : n\u00e3o se esque\u00e7a de buscar por registradores que s\u00e3o lidos antes de serem escritos. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise A fun\u00e7\u00e3o retorna algum valor? Se sim, qual seu tipo? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise A fun\u00e7\u00e3o acima combina loops e condicionais. Desenhe setas para onde as instru\u00e7\u00f5es de jmp apontam. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Com base no exerc\u00edcio anterior, entre quais linhas o loop ocorre? E a condicional? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise O loop acima tem uma vari\u00e1vel contadora. Ela est\u00e1 em qual registrador? Qual seu tipo? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Revise o funcionamento da instru\u00e7\u00e3o idiv . Em qual registrador \u00e9 armazenado o resultado da divis\u00e3o? E o resto? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Qual a condi\u00e7\u00e3o testada na condicional? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva uma vers\u00e3o do c\u00f3digo acima usando somente if-goto . Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva uma vers\u00e3o leg\u00edvel do c\u00f3digo acima. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores!","title":"07 - Loops"},{"location":"aulas/07-loops/#07-loops","text":"","title":"07 - Loops"},{"location":"aulas/07-loops/#arquivo-ex1","text":"Utilize como base o c\u00f3digo assembly abaixo (arquivo ex1 ) e responda os itens. Dump of assembler code for function soma_2n : 0 x066a <+ 0 > : mov $0x1 , %eax 0 x066f <+ 5 > : jmp 0x676 < soma_2n + 12 > 0 x0671 <+ 7 > : shr %edi 0 x0673 <+ 9 > : add $0x1 , %eax 0 x0676 <+ 12 > : cmp $0x1 , %edi 0 x0679 <+ 15 > : ja 0x671 < soma_2n + 7 > 0 x067b <+ 17 > : repz retq Exercise Localize no c\u00f3digo acima as instru\u00e7\u00f5es de saltos ( jmp ou condicionais j* ). Desenhe setas indicando para qual linha do c\u00f3digo elas pulam. Answer H\u00e1 um salto de soma_2n <+5> para soma_2n <+12> e outro de soma_2n <+15> para soma_2n <+7> Exercise Analise o fluxo de saltos do seu c\u00f3digo. Existe um loop? Entre quais linhas? Answer O loop ocorre entre as linhas +5 e +15 . Exercise Qual \u00e9 a condi\u00e7\u00e3o do loop acima? Ou seja, qual condi\u00e7\u00e3o precisa ser verdade para que o loop continue rodando ? %edi > 1 %edi < 1 %edi > 0 %eax > 1 Answer Sempre comparamos o segundo em rela\u00e7\u00e3o ao primeiro. Logo, fazemos %edi > 1 . A instru\u00e7\u00e3o ja representa a compara\u00e7\u00e3o jump above , que \u00e9 uma compara\u00e7\u00e3o de > feita entre vari\u00e1veis unsigned Exercise Com base na sua resposta acima, como voc\u00ea escreveria esse loop como um while ? Answer Considerando que o primeiro argumento da fun\u00e7\u00e3o se chama int arg1 , seria while(arg1 > 1) . Exercise Comece fazendo uma vers\u00e3o C usando somente if-goto Answer int soma_2n ( unsigned int a ) { int res = 1 ; goto verifica ; faz_algo : a = a >> 1 ; res += 1 ; verifica : if ( a > 1 ) { goto faz_algo ; } return res ; } Exercise Transforme a constru\u00e7\u00e3o que voc\u00ea fez acima em um c\u00f3digo usando while . Answer int soma_2n ( unsigned int a ) { int res = 1 ; while ( a > 1 ) { a = a / 2 ; res ++ ; } return res ; }","title":"Arquivo ex1"},{"location":"aulas/07-loops/#exercicios-para-entrega","text":"Vamos agora exercitar o que vimos na aula expositiva. Os exerc\u00edcios abaixo est\u00e3o no reposit\u00f3rio de atividades e as perguntas no handout tem o objetivo de ajudar a compreender c\u00f3digos cada vez mais complexos.","title":"Exerc\u00edcios para entrega"},{"location":"aulas/07-loops/#arquivo-ex2","text":"Leia o c\u00f3digo assembly abaixo e responda. Dump of assembler code for function soma_n : 0 x066a <+ 0 > : mov $0x0 , %edx 0 x066f <+ 5 > : mov $0x0 , %eax 0 x0674 <+ 10 > : jmp 0x67f < soma_n + 21 > 0 x0676 <+ 12 > : movslq %edx , %rcx 0 x0679 <+ 15 > : add %rcx , %rax 0 x067c <+ 18 > : add $0x1 , %edx 0 x067f <+ 21 > : cmp %edi , %edx 0 x0681 <+ 23 > : jl 0x676 < soma_n + 12 > 0 x0683 <+ 25 > : repz retq Exercise Desenhe as flechas indicando o destino de cada instru\u00e7\u00e3o de pulo ( jmp ou j* ). Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva abaixo o cabe\u00e7alho da fun\u00e7\u00e3o soma_n . Dica : procure por registradores que s\u00e3o lidos antes de serem escritos. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Fa\u00e7a a tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if-goto Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Converta o c\u00f3digo acima para uma vers\u00e3o leg\u00edvel em C . Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores!","title":"Arquivo ex2"},{"location":"aulas/07-loops/#arquivo-ex3","text":"Dump of assembler code for function ex3 : 0 x1139 <+ 0 > : mov $0x0 , %ecx 0 x113e <+ 5 > : mov $0x0 , %r8d 0 x1144 <+ 11 > : jmp 0x114a < ex4 + 17 > 0 x1146 <+ 13 > : add $0x1 , %rcx 0 x114a <+ 17 > : cmp %rdi , %rcx 0 x114d <+ 20 > : jge 0x1161 < ex4 + 40 > 0 x114f <+ 22 > : mov %rcx , %rax 0 x1152 <+ 25 > : cqto 0 x1154 <+ 27 > : idiv %rsi 0 x1157 <+ 30 > : test %rdx , %rdx 0 x115a <+ 33 > : jne 0x1146 < ex4 + 13 > 0 x115c <+ 35 > : add %rcx , %r8 0 x115f <+ 38 > : jmp 0x1146 < ex4 + 13 > 0 x1161 <+ 40 > : mov %r8 , %rax 0 x1164 <+ 43 > : retq Exercise Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Dica : n\u00e3o se esque\u00e7a de buscar por registradores que s\u00e3o lidos antes de serem escritos. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise A fun\u00e7\u00e3o retorna algum valor? Se sim, qual seu tipo? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise A fun\u00e7\u00e3o acima combina loops e condicionais. Desenhe setas para onde as instru\u00e7\u00f5es de jmp apontam. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Com base no exerc\u00edcio anterior, entre quais linhas o loop ocorre? E a condicional? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise O loop acima tem uma vari\u00e1vel contadora. Ela est\u00e1 em qual registrador? Qual seu tipo? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Revise o funcionamento da instru\u00e7\u00e3o idiv . Em qual registrador \u00e9 armazenado o resultado da divis\u00e3o? E o resto? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Qual a condi\u00e7\u00e3o testada na condicional? Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva uma vers\u00e3o do c\u00f3digo acima usando somente if-goto . Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores! Exercise Escreva uma vers\u00e3o leg\u00edvel do c\u00f3digo acima. Answer // Atividade para entrega! // Confira nos atendimentos ou chame os professores!","title":"Arquivo ex3"},{"location":"aulas/08-variaveis-locais/","text":"08 - Vari\u00e1veis locais \u00b6 Como visto na expositiva, vari\u00e1veis locais s\u00e3o armazenadas na pilha. O topo da pilha \u00e9 armazenado em %rsp e ela cresce para baixo, ou seja, ao empilhar um dado o valor de %rsp diminui e ao desempilhar seu valor aumenta. O compilador faz todo o poss\u00edvel para usar somente os registradores, por\u00e9m em alguns casos \u00e9 necess\u00e1rio guardar a vari\u00e1vel na mem\u00f3ria. Isso ocorre, em geral, quando usamos & para computar o endere\u00e7o de uma vari\u00e1vel. O exemplo mais comum nos c\u00f3digos que j\u00e1 escrevemos \u00e9 na leitura de valores usando scanf . Exemplo guiado \u00b6 Fun\u00e7\u00f5es que guardam vari\u00e1veis na pilha seguem um padr\u00e3o facilmente identific\u00e1vel. Primeiro elas subtraem um valor da pilha ( 0x10 no exemplo abaixo) correspondente ao tamanho total de todas as vari\u00e1veis usadas. Depois temos v\u00e1rias instru\u00e7\u00f5es usando endere\u00e7os relativos a %rsp e por fim devolvemos o espa\u00e7o usado somando 0x10 de volta a %rsp . sub $0x10 , %rsp . . . // c\u00f3digo da fun\u00e7\u00e3o aqui! movl 0x8 ( %rsp ), %eax mov %eax , %edx addl 0xc ( %rsp ), %edx . . . // fun\u00e7\u00e3o continua add $0x10 , %rsp ret No exemplo acima, temos duas vari\u00e1veis locais: 0x8(%rsp) e 0xc(rsp) . Cada uma \u00e9 identificada no c\u00f3digo Assembly pelo endere\u00e7o em que est\u00e1 posicionada na pilha. Logo, todo deslocamento em rela\u00e7\u00e3o a %rsp indica um acesso a vari\u00e1vel local , sendo que pode ser um acesso de leitura e escrita (usando MOV , por exemplo) ou da opera\u00e7\u00e3o endere\u00e7o de & (usando LEA ). Conseguimos identificar que seus tamanhos s\u00e3o int por duas raz\u00f5es: elas aparecem em instru\u00e7\u00f5es junto com registradores de 4 bytes ( %eax e %edx ) as instru\u00e7\u00f5es movl e addl tem o sufixo l , que indica que os dados tratados tem tamanho 4 bytes. Os sufixos suportados s\u00e3o: b - 1 byte w - 2 bytes l - 4 bytes q - 8 bytes Qualquer raz\u00e3o acima \u00e9 suficiente para identificar os tipos das vari\u00e1veis locais. Importante Novamente, nem toda instru\u00e7\u00e3o em Assembly pode ser representada em C . As instru\u00e7\u00f5es sub 0x10, %rsp e add 0x10, %rsp representam a cria\u00e7\u00e3o de vari\u00e1veis locais na pilha e n\u00e3o tem equivalente em C . Simplesmente ignoramos elas e usamos as vari\u00e1veis locais no c\u00f3digo. Revis\u00e3o de vari\u00e1veis globais e strings constantes \u00b6 Antes de iniciar o pr\u00f3ximo exerc\u00edcio vamos revisar como vari\u00e1veis locais, globais e strings constantes s\u00e3o acessadas em c\u00f3digo assembly. A imagem abaixo exemplifica os tr\u00eas casos: Vari\u00e1veis locais : s\u00e3o acessadas com lea (para & - endere\u00e7o de) ou mov (para leituras e escritas) relativos a %rsp Globais e strings constantes : s\u00e3o acessadas usando a nota\u00e7\u00e3o 0xYY(%rip) , sendo que o valor 0xYY muda a cada acesso. No caso das strings, o acesso a estes endere\u00e7os \u00e9 somente leitura. O endere\u00e7amento relativo a %rip leva em conta a posi\u00e7\u00e3o relativa entre a instru\u00e7\u00e3o atual e o endere\u00e7o de mem\u00f3ria do dado. Na imagem acima est\u00e3o destacadas duas instru\u00e7\u00f5es lea que acessam o mesmo dado. Como o %rip (ponteiro para a pr\u00f3xima instru\u00e7\u00e3o) \u00e9 diferente precisamos de deslocamentos diferentes para acessar o mesmo dado. Dica : o gdb coloca o endere\u00e7o calculado ao lado das instru\u00e7\u00f5es deste tipo. Exercise \u00c9 poss\u00edvel que o lea abaixo seja aritm\u00e9tico? Por que? lea 0x8 ( %rsp ), %rdx Answer N\u00e3o! O registrador %rsp \u00e9 especial e sempre guarda o endere\u00e7o do topo da pilha de chamadas. Nesse espa\u00e7o de mem\u00f3ria guardamos todas vari\u00e1veis que n\u00e3o podem ser alocadas em um registrador. Arquivo ex2 \u00b6 O c\u00f3digo abaixo ( ex2 ) utiliza vari\u00e1veis locais. Dump of assembler code for function func1 : 0 x05fe <+ 0 > : sub $0x10 , %rsp 0 x0602 <+ 4 > : movl $0xa , 0xc ( %rsp ) 0 x060a <+ 12 > : movl $0xb , 0x8 ( %rsp ) 0 x0612 <+ 20 > : lea 0xc ( %rsp ), %rdi 0 x0617 <+ 25 > : callq 0x5fa < func2 > 0 x061c <+ 30 > : addl $0x1 , 0x8 ( %rsp ) 0 x0621 <+ 35 > : lea 0x8 ( %rsp ), %rdi 0 x0626 <+ 40 > : callq 0x5fa < func2 > 0 x062b <+ 45 > : add $0x10 , %rsp 0 x062f <+ 49 > : retq Vamos come\u00e7ar analisando as tr\u00eas primeiras linhas do programa. Exercise Quanto espa\u00e7o (em bytes) \u00e9 reservado na pilha? 10 16 20 8 Answer Ao executar sub $0x10,%rsp criamos um espa\u00e7o de 16 bytes ( 0x10 ) na pilha. Note que as constantes sempre aparecem em hexadecimal. Existem v\u00e1rios momentos no c\u00f3digo que lemos/escrevemos em endere\u00e7os relativos a %rsp . Cada deslocamento representa uma vari\u00e1vel local que est\u00e1 armazenada na mem\u00f3ria. Exercise Quantas vari\u00e1veis s\u00e3o inicializadas e quais seus tamanhos? 2 - int 2 - long 1 - int 1 - long Answer S\u00e3o duas vari\u00e1veis int : uma em 0xc(%rsp) e outra em 0x8(%rsp) . Exercise Identifique onde as vari\u00e1veis locais encontradas s\u00e3o usadas. D\u00ea um nome para cada uma delas. Answer Vou utilizar os identificadores e tipos int a e int b . Exercise Os lea das linhas +20 e +35 podem ser aritm\u00e9ticos? SIM N\u00c3O Answer N\u00e3o s\u00e3o aritm\u00e9ticos, portanto representam a opera\u00e7\u00e3o endere\u00e7o de & . Exercise Com base em sua resposta acima, traduza as chamadas de fun\u00e7\u00e3o que ocorrem nas linhas +25 e +40 . Answer Na linha +25 ocorre a chamada func2(&a) . J\u00e1 na linha +40 a chamada \u00e9 func2(&b) Exercise Traduza o programa acima para C Answer void func2 ( int * a ) { * a += 1 ; } void func1 () { int a = 10 ; int b = 11 ; func2 ( & a ); b ++ ; func2 ( & b ); } Arquivo ex3 \u00b6 No exerc\u00edcio anterior vimos como passar vari\u00e1veis por refer\u00eancia para outras fun\u00e7\u00f5es. Agora veremos como trabalhar com scanf . Veja abaixo a fun\u00e7\u00e3o main do execut\u00e1vel ex3 . Abra este arquivo usando o gdb e siga os exerc\u00edcios. Dump of assembler code for function main : 0 x1149 <+ 0 > : sub $0x18 , %rsp 0 x114d <+ 4 > : lea 0xc ( %rsp ), %rsi 0 x1152 <+ 9 > : lea 0xeab ( %rip ), %rdi # 0x2004 0 x1159 <+ 16 > : mov $0x0 , %eax 0 x115e <+ 21 > : callq 0x1040 < __isoc99_scanf@plt > 0 x1163 <+ 26 > : cmpl $0x0 , 0xc ( %rsp ) 0 x1168 <+ 31 > : js 0x1180 < main + 55 > 0 x116a <+ 33 > : lea 0xe9f ( %rip ), %rdi # 0x2010 0 x1171 <+ 40 > : callq 0x1030 < puts@plt > 0 x1176 <+ 45 > : mov $0x0 , %eax 0 x117b <+ 50 > : add $0x18 , %rsp 0 x117f <+ 54 > : retq 0 x1180 <+ 55 > : lea 0xe80 ( %rip ), %rdi # 0x2007 0 x1187 <+ 62 > : callq 0x1030 < puts@plt > 0 x118c <+ 67 > : jmp 0x1176 < main + 45 > Exercise Vamos come\u00e7ar procurando por vari\u00e1veis locais que estejam na pilha. Quanto espa\u00e7o \u00e9 reservado para elas? Liste abaixo as que voc\u00ea encontrou e d\u00ea um nome para cada uma. Dica : todo acesso relativo a %rsp representa um acesso a vari\u00e1vel local. Answer Est\u00e3o sendo reservados 24 bytes na pilha. Temos uma vari\u00e1vel local int n . Exercise A instru\u00e7\u00e3o call em main+21 \u00e9 um scanf . O primeiro argumento \u00e9 a string de formata\u00e7\u00e3o. Use o comando x do gdb para encontrar ela na mem\u00f3ria. Dica : usamos este comando nas aulas 02 e 03. Answer A string de formata\u00e7\u00e3o \u00e9 \"%d\". Exercise O segundo argumento do scanf \u00e9 o endere\u00e7o da vari\u00e1vel a ser preenchida. O endere\u00e7o de qual vari\u00e1vel local \u00e9 passado? Answer \u00c9 o endere\u00e7o da vari\u00e1vel correspondente a 0xc(%rsp) Exercise Reconstrua a chamada do scanf acima. Answer int a; // demos esse nome para todas ocorr\u00eancias de 0x(%rsp) scanf(\"%d\", &a); Com a chamada do scanf pronta, vamos analisar o restante do c\u00f3digo. Exercise Agora examinaremos as chamadas em main+40 e main+62 . Elas s\u00e3o para a fun\u00e7\u00e3o puts . Veja sua documenta\u00e7\u00e3o (procure por C puts .) e explique abaixo o qu\u00ea ela faz e quais s\u00e3o seus argumentos. Answer Escreve os m\u00faltiplos caracteres de uma string, seguido de \\n , na sa\u00edda padr\u00e3o Exercise Com base na explica\u00e7\u00e3o acima, escreva abaixo os argumentos passados para cada chamada. Answer S\u00e3o feitas duas chamadas: a primeira \u00e9 puts(\"Positivo\") e a segunda \u00e9 puts(\"Negativo\") . Exercise Traduza o c\u00f3digo acima para um vers\u00e3o em C . Answer #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); if ( n < 0 ) { printf ( \"Negativo \\n \" ); } else { printf ( \"Positivo! \\n \" ); } return 0 ; } Entrega \u00b6 Exerc\u00edcios 4 e 5 da atv5 dispon\u00edveis no reposit\u00f3rio de atividades.","title":"08 - Vari\u00e1veis locais"},{"location":"aulas/08-variaveis-locais/#08-variaveis-locais","text":"Como visto na expositiva, vari\u00e1veis locais s\u00e3o armazenadas na pilha. O topo da pilha \u00e9 armazenado em %rsp e ela cresce para baixo, ou seja, ao empilhar um dado o valor de %rsp diminui e ao desempilhar seu valor aumenta. O compilador faz todo o poss\u00edvel para usar somente os registradores, por\u00e9m em alguns casos \u00e9 necess\u00e1rio guardar a vari\u00e1vel na mem\u00f3ria. Isso ocorre, em geral, quando usamos & para computar o endere\u00e7o de uma vari\u00e1vel. O exemplo mais comum nos c\u00f3digos que j\u00e1 escrevemos \u00e9 na leitura de valores usando scanf .","title":"08 - Vari\u00e1veis locais"},{"location":"aulas/08-variaveis-locais/#exemplo-guiado","text":"Fun\u00e7\u00f5es que guardam vari\u00e1veis na pilha seguem um padr\u00e3o facilmente identific\u00e1vel. Primeiro elas subtraem um valor da pilha ( 0x10 no exemplo abaixo) correspondente ao tamanho total de todas as vari\u00e1veis usadas. Depois temos v\u00e1rias instru\u00e7\u00f5es usando endere\u00e7os relativos a %rsp e por fim devolvemos o espa\u00e7o usado somando 0x10 de volta a %rsp . sub $0x10 , %rsp . . . // c\u00f3digo da fun\u00e7\u00e3o aqui! movl 0x8 ( %rsp ), %eax mov %eax , %edx addl 0xc ( %rsp ), %edx . . . // fun\u00e7\u00e3o continua add $0x10 , %rsp ret No exemplo acima, temos duas vari\u00e1veis locais: 0x8(%rsp) e 0xc(rsp) . Cada uma \u00e9 identificada no c\u00f3digo Assembly pelo endere\u00e7o em que est\u00e1 posicionada na pilha. Logo, todo deslocamento em rela\u00e7\u00e3o a %rsp indica um acesso a vari\u00e1vel local , sendo que pode ser um acesso de leitura e escrita (usando MOV , por exemplo) ou da opera\u00e7\u00e3o endere\u00e7o de & (usando LEA ). Conseguimos identificar que seus tamanhos s\u00e3o int por duas raz\u00f5es: elas aparecem em instru\u00e7\u00f5es junto com registradores de 4 bytes ( %eax e %edx ) as instru\u00e7\u00f5es movl e addl tem o sufixo l , que indica que os dados tratados tem tamanho 4 bytes. Os sufixos suportados s\u00e3o: b - 1 byte w - 2 bytes l - 4 bytes q - 8 bytes Qualquer raz\u00e3o acima \u00e9 suficiente para identificar os tipos das vari\u00e1veis locais. Importante Novamente, nem toda instru\u00e7\u00e3o em Assembly pode ser representada em C . As instru\u00e7\u00f5es sub 0x10, %rsp e add 0x10, %rsp representam a cria\u00e7\u00e3o de vari\u00e1veis locais na pilha e n\u00e3o tem equivalente em C . Simplesmente ignoramos elas e usamos as vari\u00e1veis locais no c\u00f3digo.","title":"Exemplo guiado"},{"location":"aulas/08-variaveis-locais/#revisao-de-variaveis-globais-e-strings-constantes","text":"Antes de iniciar o pr\u00f3ximo exerc\u00edcio vamos revisar como vari\u00e1veis locais, globais e strings constantes s\u00e3o acessadas em c\u00f3digo assembly. A imagem abaixo exemplifica os tr\u00eas casos: Vari\u00e1veis locais : s\u00e3o acessadas com lea (para & - endere\u00e7o de) ou mov (para leituras e escritas) relativos a %rsp Globais e strings constantes : s\u00e3o acessadas usando a nota\u00e7\u00e3o 0xYY(%rip) , sendo que o valor 0xYY muda a cada acesso. No caso das strings, o acesso a estes endere\u00e7os \u00e9 somente leitura. O endere\u00e7amento relativo a %rip leva em conta a posi\u00e7\u00e3o relativa entre a instru\u00e7\u00e3o atual e o endere\u00e7o de mem\u00f3ria do dado. Na imagem acima est\u00e3o destacadas duas instru\u00e7\u00f5es lea que acessam o mesmo dado. Como o %rip (ponteiro para a pr\u00f3xima instru\u00e7\u00e3o) \u00e9 diferente precisamos de deslocamentos diferentes para acessar o mesmo dado. Dica : o gdb coloca o endere\u00e7o calculado ao lado das instru\u00e7\u00f5es deste tipo. Exercise \u00c9 poss\u00edvel que o lea abaixo seja aritm\u00e9tico? Por que? lea 0x8 ( %rsp ), %rdx Answer N\u00e3o! O registrador %rsp \u00e9 especial e sempre guarda o endere\u00e7o do topo da pilha de chamadas. Nesse espa\u00e7o de mem\u00f3ria guardamos todas vari\u00e1veis que n\u00e3o podem ser alocadas em um registrador.","title":"Revis\u00e3o de vari\u00e1veis globais e strings constantes"},{"location":"aulas/08-variaveis-locais/#arquivo-ex2","text":"O c\u00f3digo abaixo ( ex2 ) utiliza vari\u00e1veis locais. Dump of assembler code for function func1 : 0 x05fe <+ 0 > : sub $0x10 , %rsp 0 x0602 <+ 4 > : movl $0xa , 0xc ( %rsp ) 0 x060a <+ 12 > : movl $0xb , 0x8 ( %rsp ) 0 x0612 <+ 20 > : lea 0xc ( %rsp ), %rdi 0 x0617 <+ 25 > : callq 0x5fa < func2 > 0 x061c <+ 30 > : addl $0x1 , 0x8 ( %rsp ) 0 x0621 <+ 35 > : lea 0x8 ( %rsp ), %rdi 0 x0626 <+ 40 > : callq 0x5fa < func2 > 0 x062b <+ 45 > : add $0x10 , %rsp 0 x062f <+ 49 > : retq Vamos come\u00e7ar analisando as tr\u00eas primeiras linhas do programa. Exercise Quanto espa\u00e7o (em bytes) \u00e9 reservado na pilha? 10 16 20 8 Answer Ao executar sub $0x10,%rsp criamos um espa\u00e7o de 16 bytes ( 0x10 ) na pilha. Note que as constantes sempre aparecem em hexadecimal. Existem v\u00e1rios momentos no c\u00f3digo que lemos/escrevemos em endere\u00e7os relativos a %rsp . Cada deslocamento representa uma vari\u00e1vel local que est\u00e1 armazenada na mem\u00f3ria. Exercise Quantas vari\u00e1veis s\u00e3o inicializadas e quais seus tamanhos? 2 - int 2 - long 1 - int 1 - long Answer S\u00e3o duas vari\u00e1veis int : uma em 0xc(%rsp) e outra em 0x8(%rsp) . Exercise Identifique onde as vari\u00e1veis locais encontradas s\u00e3o usadas. D\u00ea um nome para cada uma delas. Answer Vou utilizar os identificadores e tipos int a e int b . Exercise Os lea das linhas +20 e +35 podem ser aritm\u00e9ticos? SIM N\u00c3O Answer N\u00e3o s\u00e3o aritm\u00e9ticos, portanto representam a opera\u00e7\u00e3o endere\u00e7o de & . Exercise Com base em sua resposta acima, traduza as chamadas de fun\u00e7\u00e3o que ocorrem nas linhas +25 e +40 . Answer Na linha +25 ocorre a chamada func2(&a) . J\u00e1 na linha +40 a chamada \u00e9 func2(&b) Exercise Traduza o programa acima para C Answer void func2 ( int * a ) { * a += 1 ; } void func1 () { int a = 10 ; int b = 11 ; func2 ( & a ); b ++ ; func2 ( & b ); }","title":"Arquivo ex2"},{"location":"aulas/08-variaveis-locais/#arquivo-ex3","text":"No exerc\u00edcio anterior vimos como passar vari\u00e1veis por refer\u00eancia para outras fun\u00e7\u00f5es. Agora veremos como trabalhar com scanf . Veja abaixo a fun\u00e7\u00e3o main do execut\u00e1vel ex3 . Abra este arquivo usando o gdb e siga os exerc\u00edcios. Dump of assembler code for function main : 0 x1149 <+ 0 > : sub $0x18 , %rsp 0 x114d <+ 4 > : lea 0xc ( %rsp ), %rsi 0 x1152 <+ 9 > : lea 0xeab ( %rip ), %rdi # 0x2004 0 x1159 <+ 16 > : mov $0x0 , %eax 0 x115e <+ 21 > : callq 0x1040 < __isoc99_scanf@plt > 0 x1163 <+ 26 > : cmpl $0x0 , 0xc ( %rsp ) 0 x1168 <+ 31 > : js 0x1180 < main + 55 > 0 x116a <+ 33 > : lea 0xe9f ( %rip ), %rdi # 0x2010 0 x1171 <+ 40 > : callq 0x1030 < puts@plt > 0 x1176 <+ 45 > : mov $0x0 , %eax 0 x117b <+ 50 > : add $0x18 , %rsp 0 x117f <+ 54 > : retq 0 x1180 <+ 55 > : lea 0xe80 ( %rip ), %rdi # 0x2007 0 x1187 <+ 62 > : callq 0x1030 < puts@plt > 0 x118c <+ 67 > : jmp 0x1176 < main + 45 > Exercise Vamos come\u00e7ar procurando por vari\u00e1veis locais que estejam na pilha. Quanto espa\u00e7o \u00e9 reservado para elas? Liste abaixo as que voc\u00ea encontrou e d\u00ea um nome para cada uma. Dica : todo acesso relativo a %rsp representa um acesso a vari\u00e1vel local. Answer Est\u00e3o sendo reservados 24 bytes na pilha. Temos uma vari\u00e1vel local int n . Exercise A instru\u00e7\u00e3o call em main+21 \u00e9 um scanf . O primeiro argumento \u00e9 a string de formata\u00e7\u00e3o. Use o comando x do gdb para encontrar ela na mem\u00f3ria. Dica : usamos este comando nas aulas 02 e 03. Answer A string de formata\u00e7\u00e3o \u00e9 \"%d\". Exercise O segundo argumento do scanf \u00e9 o endere\u00e7o da vari\u00e1vel a ser preenchida. O endere\u00e7o de qual vari\u00e1vel local \u00e9 passado? Answer \u00c9 o endere\u00e7o da vari\u00e1vel correspondente a 0xc(%rsp) Exercise Reconstrua a chamada do scanf acima. Answer int a; // demos esse nome para todas ocorr\u00eancias de 0x(%rsp) scanf(\"%d\", &a); Com a chamada do scanf pronta, vamos analisar o restante do c\u00f3digo. Exercise Agora examinaremos as chamadas em main+40 e main+62 . Elas s\u00e3o para a fun\u00e7\u00e3o puts . Veja sua documenta\u00e7\u00e3o (procure por C puts .) e explique abaixo o qu\u00ea ela faz e quais s\u00e3o seus argumentos. Answer Escreve os m\u00faltiplos caracteres de uma string, seguido de \\n , na sa\u00edda padr\u00e3o Exercise Com base na explica\u00e7\u00e3o acima, escreva abaixo os argumentos passados para cada chamada. Answer S\u00e3o feitas duas chamadas: a primeira \u00e9 puts(\"Positivo\") e a segunda \u00e9 puts(\"Negativo\") . Exercise Traduza o c\u00f3digo acima para um vers\u00e3o em C . Answer #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); if ( n < 0 ) { printf ( \"Negativo \\n \" ); } else { printf ( \"Positivo! \\n \" ); } return 0 ; }","title":"Arquivo ex3"},{"location":"aulas/08-variaveis-locais/#entrega","text":"Exerc\u00edcios 4 e 5 da atv5 dispon\u00edveis no reposit\u00f3rio de atividades.","title":"Entrega"},{"location":"aulas/09-arrays/","text":"09 - Array em Assembly \u00b6 A parte final de nossas atividades com Assembly \u00e9 entender Arrays . J\u00e1 estudamos todo o necess\u00e1rio para lidar com eles: um array \u00e9 representado por um apontador para seu primeiro elemento. J\u00e1 estudamos ponteiros e a escrita em mem\u00f3ria com MOV . ao acessar o elemento i de long *vec estamos acessando o endere\u00e7o &vec[0] + sizeof(long) * i . A nota\u00e7\u00e3o de c\u00e1lculos de endere\u00e7o de mem\u00f3ria faz exatamente isso. Para iniciar vamos revisar a nota\u00e7\u00e3o de c\u00e1lculo de endere\u00e7os de mem\u00f3ria: D(%reg1, %reg2, S) , onde D \u00e9 um n\u00famero inteiro que representa um deslocamento constante a partir do endere\u00e7o guardado em %reg1 %reg1 cont\u00e9m o endere\u00e7o do primeiro elemento do vetor %reg2 cont\u00e9m o \u00edndice do elemento a ser acessado S cont\u00e9m o tamanho de cada elemento do vetor e pode ser 1, 2, 4 ou 8 . O acesso \u00e9 feito ao endere\u00e7o D + %reg1 + %reg2 * S . Ou seja, primeiro computamos o endere\u00e7o e depois acessamos a mem\u00f3ria no endere\u00e7o computado . Exercise Supondo que %rsi=0x24, %rdi=0x8 , o valor final da express\u00e3o (%rsi, %rdi, 4) \u00e9 0x32 0x48 0x56 0x44 Answer Tudo est\u00e1 em hexa. A conta \u00e9 36 + 4 * 8 = 68 . Exercise Supondo que %rdx=0x44 , o valor da express\u00e3o 0x12(%rdx) \u00e9 0x56 0x44 0x52 Answer Tudo est\u00e1 em hexa. A conta \u00e9 18 + 68 = 86 = 0x56 . Exemplo guiado \u00b6 Dado o array int *vec (guardado em %rdx ). A atribui\u00e7\u00e3o de 5 ao elemento i (guardado em %ecx ) seria traduzida como MOVL $0x5 , ( %rdx , %rcx , 4 ) Importante Lembre-se de que apontadores s\u00e3o tipos de dados com tamanho 8 bytes . Considerando um vetor short *vec e que o endere\u00e7o do primeiro elemento de vec esteja em %rdi , Exercise Qual a instru\u00e7\u00e3o usada para mover o conte\u00fado de vec[i] para o registrador %eax ?(supondo que o valor de i esteja em %esi ) Answer mov (%rdi, %rsi, 2), %eax Exercise Qual a instru\u00e7\u00e3o usada para mover &vec[i] para o registrador %eax ? Dica : como voc\u00ea implementava o operador & com vari\u00e1veis locais? Answer lea (%rdi, %rsi, 2), %eax Exerc\u00edcio 1 - fun\u00e7\u00e3o soma \u00b6 Veja o c\u00f3digo abaixo e responda as perguntas. Dump of assembler code for function soma : 0 x0000 <+ 0 > : mov $0x0 , %edx 0 x0005 <+ 5 > : mov $0x0 , %eax 0 x000a <+ 10 > : jmp 0x15 < soma + 21 > 0 x000c <+ 12 > : movslq %edx , %rcx 0 x000f <+ 15 > : add ( %rdi , %rcx , 4 ), %eax 0 x0012 <+ 18 > : add $0x1 , %edx 0 x0015 <+ 21 > : cmp %esi , %edx 0 x0017 <+ 23 > : jl 0xc < soma + 12 > 0 x0019 <+ 25 > : repz retq Exercise A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Answer Em <soma+0> , usa-se %edx para escrita . Em <soma+5> , usa-se %eax para escrita . Em <soma+12> , usa-se %rcx para escrita . Em <soma+15> , usa-se %rdi para leitura . Em <soma+21> , usa-se %esi para leitura . Exercise Se o primeiro acesso ao registrador \u00e9 de escrita ent\u00e3o ele provavelmente n\u00e3o \u00e9 um par\u00e2metro. Com base nisto, escreva abaixo a declara\u00e7\u00e3o da fun\u00e7\u00e3o acima. Answer int soma ( int * vec , int n ) Exercise Sempre que escrevemos a nota\u00e7\u00e3o de acesso \u00e0 mem\u00f3ria D(%reg1, %reg2, S) precisamos usar registradores de 64 bits nos lugares de reg1 e reg2 . Com base nisto, explique qual o uso feito do registrador %edx e porqu\u00ea usamos a instru\u00e7\u00e3o movslq na linha c (ou <soma+12> ). Answer Faz o casting com sinal de 4 bytes para 8 bytes. Ent\u00e3o o c\u00f3digo-fonte original deve utilizar uma vari\u00e1vel int i (4 bytes) para controlar o \u00edndice do vetor. Para que a instru\u00e7\u00e3o seja realizada, faz-se um casting para long . Exercise Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer \\\\ confira com os professores Acesso a elementos constantes \u00b6 O acesso a elementos \"constantes\", como long v[10]; v[5] = 0; , n\u00e3o \u00e9 feito usando a nota\u00e7\u00e3o acima, pois o compilador j\u00e1 sabe em tempo de compila\u00e7\u00e3o , qual \u00e9 o deslocamento necess\u00e1rio para encontrar a posi\u00e7\u00e3o 6 de v . Considerando o exemplo acima, responda. Exercise Supondo que v=0x100 , qual o \u00e9 o endere\u00e7o de v[5] ? Answer Cada long ocupa 8 bytes, logo o elemento v[5] est\u00e1 40 bytes ap\u00f3s o in\u00edcio do vetor. Logo, o endere\u00e7o de v[5] \u00e9 0x100 + 0x028 = 0x128 . Exercise Escreva a instru\u00e7\u00e3o usada para mover o valor 0 para v[5] (supondo que o endere\u00e7o do primeiro elemento esteja em %rdi ). Answer mov $0, 0x28(%rdi) = In\u00edcio de %rdi + 40 bytes. Importante O compilador pode (e vai) aplicar diversas otimiza\u00e7\u00f5es para economizar o m\u00e1ximo poss\u00edvel. Por essa raz\u00e3o, \u00e9 importante saber calcular os endere\u00e7os de mem\u00f3ria na m\u00e3o. Assim conseguimos \"refazer\" o processo que gerou a otimiza\u00e7\u00e3o e entender melhor o c\u00f3digo C original. Exerc\u00edcio 2 - fun\u00e7\u00e3o func_que_recebe_array \u00b6 Dump of assembler code for function func_que_recebe_array : 0 x0000 <+ 0 > : mov 0x4 ( %rdi ), %eax 0 x0003 <+ 3 > : add ( %rdi ), %eax 0 x0005 <+ 5 > : cmp 0x8 ( %rdi ), %eax 0 x0008 <+ 8 > : setl %al 0 x000b <+ 11 > : movzbl %al , %eax 0 x000e <+ 14 > : retq Exercise Temos acessos \u00e0 mem\u00f3ria relativos ao endere\u00e7o passado em %rdi nas linhas 0, 3 e 5 . Isto significa que %rdi \u00e9 um ponteiro. Pelos tipos de acessos feitos, voc\u00ea consegue identificar para qual tipo de vari\u00e1vel ele aponta? Answer Como em na linha <+0> o vetor est\u00e1 sendo lido em um registrador de 4 bytes, identificamos como int Exercise Traduza os acessos de mem\u00f3ria feitos nas linhas citadas acima para a nota\u00e7\u00e3o de acesso a arrays em C . Answer Em <+0> faz-se aux = vec[1] . Em <+03> o acesso \u00e9 aux = vec[0] + aux . Exercise Com base no respondido acima, fa\u00e7a uma vers\u00e3o em C leg\u00edvel do c\u00f3digo asembly acima. Se ajudar, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha do Assembly e depois torne-a leg\u00edvel. Answer int func_que_recebe_array ( int * arr ) { long c = arr [ 0 ] + arr [ 1 ]; return c < arr [ 2 ]; } Exerc\u00edcio 3 - fun\u00e7\u00e3o first_neg \u00b6 Veja agora o c\u00f3digo abaixo e responda. Dump of assembler code for function first_neg : 0 x0000 <+ 0 > : mov $0x0 , %eax 0 x0005 <+ 5 > : cmp %esi , %eax 0 x0007 <+ 7 > : jge 0x17 < first_neg + 23 > 0 x0009 <+ 9 > : movslq %eax , %rdx 0 x000c <+ 12 > : cmpl $0x0 ,( %rdi , %rdx , 4 ) 0 x0010 <+ 16 > : js 0x17 < first_neg + 23 > 0 x0012 <+ 18 > : add $0x1 , %eax 0 x0015 <+ 21 > : jmp 0x5 < first_neg + 5 > 0 x0017 <+ 23 > : repz retq Exercise A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Answer Em <first_neg+0> , usa-se %eax para escrita . Em <first_neg+5> , usa-se %esi para leitura . Em <first_neg+12> , usa-se %rdi para leitura . Exercise Desenhe setas indicando o destino dos pulos no c\u00f3digo acima. Voc\u00ea consegue idenfiticar quais estruturas de controle? Entre quais linhas? Answer Confira com os professores Exercise Fa\u00e7a uma vers\u00e3o em C usando if-goto do c\u00f3digo acima. Answer int first_neg ( int * vec , int n ) { res = 0 ; loop : if ( res >= n ) { goto retorno ; } if ( vec [ res ] < 0 ) { goto retorno ; } res = res + 1 ; goto loop : retorno : return res ; } Exercise Transforme seu c\u00f3digo em uma vers\u00e3o leg\u00edvel. Answer int first_neg ( int * vec , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( vec [ i ] < 0 ) { return i ; } } }","title":"09 - Array em Assembly"},{"location":"aulas/09-arrays/#09-array-em-assembly","text":"A parte final de nossas atividades com Assembly \u00e9 entender Arrays . J\u00e1 estudamos todo o necess\u00e1rio para lidar com eles: um array \u00e9 representado por um apontador para seu primeiro elemento. J\u00e1 estudamos ponteiros e a escrita em mem\u00f3ria com MOV . ao acessar o elemento i de long *vec estamos acessando o endere\u00e7o &vec[0] + sizeof(long) * i . A nota\u00e7\u00e3o de c\u00e1lculos de endere\u00e7o de mem\u00f3ria faz exatamente isso. Para iniciar vamos revisar a nota\u00e7\u00e3o de c\u00e1lculo de endere\u00e7os de mem\u00f3ria: D(%reg1, %reg2, S) , onde D \u00e9 um n\u00famero inteiro que representa um deslocamento constante a partir do endere\u00e7o guardado em %reg1 %reg1 cont\u00e9m o endere\u00e7o do primeiro elemento do vetor %reg2 cont\u00e9m o \u00edndice do elemento a ser acessado S cont\u00e9m o tamanho de cada elemento do vetor e pode ser 1, 2, 4 ou 8 . O acesso \u00e9 feito ao endere\u00e7o D + %reg1 + %reg2 * S . Ou seja, primeiro computamos o endere\u00e7o e depois acessamos a mem\u00f3ria no endere\u00e7o computado . Exercise Supondo que %rsi=0x24, %rdi=0x8 , o valor final da express\u00e3o (%rsi, %rdi, 4) \u00e9 0x32 0x48 0x56 0x44 Answer Tudo est\u00e1 em hexa. A conta \u00e9 36 + 4 * 8 = 68 . Exercise Supondo que %rdx=0x44 , o valor da express\u00e3o 0x12(%rdx) \u00e9 0x56 0x44 0x52 Answer Tudo est\u00e1 em hexa. A conta \u00e9 18 + 68 = 86 = 0x56 .","title":"09 - Array em Assembly"},{"location":"aulas/09-arrays/#exemplo-guiado","text":"Dado o array int *vec (guardado em %rdx ). A atribui\u00e7\u00e3o de 5 ao elemento i (guardado em %ecx ) seria traduzida como MOVL $0x5 , ( %rdx , %rcx , 4 ) Importante Lembre-se de que apontadores s\u00e3o tipos de dados com tamanho 8 bytes . Considerando um vetor short *vec e que o endere\u00e7o do primeiro elemento de vec esteja em %rdi , Exercise Qual a instru\u00e7\u00e3o usada para mover o conte\u00fado de vec[i] para o registrador %eax ?(supondo que o valor de i esteja em %esi ) Answer mov (%rdi, %rsi, 2), %eax Exercise Qual a instru\u00e7\u00e3o usada para mover &vec[i] para o registrador %eax ? Dica : como voc\u00ea implementava o operador & com vari\u00e1veis locais? Answer lea (%rdi, %rsi, 2), %eax","title":"Exemplo guiado"},{"location":"aulas/09-arrays/#exercicio-1-funcao-soma","text":"Veja o c\u00f3digo abaixo e responda as perguntas. Dump of assembler code for function soma : 0 x0000 <+ 0 > : mov $0x0 , %edx 0 x0005 <+ 5 > : mov $0x0 , %eax 0 x000a <+ 10 > : jmp 0x15 < soma + 21 > 0 x000c <+ 12 > : movslq %edx , %rcx 0 x000f <+ 15 > : add ( %rdi , %rcx , 4 ), %eax 0 x0012 <+ 18 > : add $0x1 , %edx 0 x0015 <+ 21 > : cmp %esi , %edx 0 x0017 <+ 23 > : jl 0xc < soma + 12 > 0 x0019 <+ 25 > : repz retq Exercise A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Answer Em <soma+0> , usa-se %edx para escrita . Em <soma+5> , usa-se %eax para escrita . Em <soma+12> , usa-se %rcx para escrita . Em <soma+15> , usa-se %rdi para leitura . Em <soma+21> , usa-se %esi para leitura . Exercise Se o primeiro acesso ao registrador \u00e9 de escrita ent\u00e3o ele provavelmente n\u00e3o \u00e9 um par\u00e2metro. Com base nisto, escreva abaixo a declara\u00e7\u00e3o da fun\u00e7\u00e3o acima. Answer int soma ( int * vec , int n ) Exercise Sempre que escrevemos a nota\u00e7\u00e3o de acesso \u00e0 mem\u00f3ria D(%reg1, %reg2, S) precisamos usar registradores de 64 bits nos lugares de reg1 e reg2 . Com base nisto, explique qual o uso feito do registrador %edx e porqu\u00ea usamos a instru\u00e7\u00e3o movslq na linha c (ou <soma+12> ). Answer Faz o casting com sinal de 4 bytes para 8 bytes. Ent\u00e3o o c\u00f3digo-fonte original deve utilizar uma vari\u00e1vel int i (4 bytes) para controlar o \u00edndice do vetor. Para que a instru\u00e7\u00e3o seja realizada, faz-se um casting para long . Exercise Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer \\\\ confira com os professores","title":"Exerc\u00edcio 1 - fun\u00e7\u00e3o soma"},{"location":"aulas/09-arrays/#acesso-a-elementos-constantes","text":"O acesso a elementos \"constantes\", como long v[10]; v[5] = 0; , n\u00e3o \u00e9 feito usando a nota\u00e7\u00e3o acima, pois o compilador j\u00e1 sabe em tempo de compila\u00e7\u00e3o , qual \u00e9 o deslocamento necess\u00e1rio para encontrar a posi\u00e7\u00e3o 6 de v . Considerando o exemplo acima, responda. Exercise Supondo que v=0x100 , qual o \u00e9 o endere\u00e7o de v[5] ? Answer Cada long ocupa 8 bytes, logo o elemento v[5] est\u00e1 40 bytes ap\u00f3s o in\u00edcio do vetor. Logo, o endere\u00e7o de v[5] \u00e9 0x100 + 0x028 = 0x128 . Exercise Escreva a instru\u00e7\u00e3o usada para mover o valor 0 para v[5] (supondo que o endere\u00e7o do primeiro elemento esteja em %rdi ). Answer mov $0, 0x28(%rdi) = In\u00edcio de %rdi + 40 bytes. Importante O compilador pode (e vai) aplicar diversas otimiza\u00e7\u00f5es para economizar o m\u00e1ximo poss\u00edvel. Por essa raz\u00e3o, \u00e9 importante saber calcular os endere\u00e7os de mem\u00f3ria na m\u00e3o. Assim conseguimos \"refazer\" o processo que gerou a otimiza\u00e7\u00e3o e entender melhor o c\u00f3digo C original.","title":"Acesso a elementos constantes"},{"location":"aulas/09-arrays/#exercicio-2-funcao-func_que_recebe_array","text":"Dump of assembler code for function func_que_recebe_array : 0 x0000 <+ 0 > : mov 0x4 ( %rdi ), %eax 0 x0003 <+ 3 > : add ( %rdi ), %eax 0 x0005 <+ 5 > : cmp 0x8 ( %rdi ), %eax 0 x0008 <+ 8 > : setl %al 0 x000b <+ 11 > : movzbl %al , %eax 0 x000e <+ 14 > : retq Exercise Temos acessos \u00e0 mem\u00f3ria relativos ao endere\u00e7o passado em %rdi nas linhas 0, 3 e 5 . Isto significa que %rdi \u00e9 um ponteiro. Pelos tipos de acessos feitos, voc\u00ea consegue identificar para qual tipo de vari\u00e1vel ele aponta? Answer Como em na linha <+0> o vetor est\u00e1 sendo lido em um registrador de 4 bytes, identificamos como int Exercise Traduza os acessos de mem\u00f3ria feitos nas linhas citadas acima para a nota\u00e7\u00e3o de acesso a arrays em C . Answer Em <+0> faz-se aux = vec[1] . Em <+03> o acesso \u00e9 aux = vec[0] + aux . Exercise Com base no respondido acima, fa\u00e7a uma vers\u00e3o em C leg\u00edvel do c\u00f3digo asembly acima. Se ajudar, fa\u00e7a uma tradu\u00e7\u00e3o linha a linha do Assembly e depois torne-a leg\u00edvel. Answer int func_que_recebe_array ( int * arr ) { long c = arr [ 0 ] + arr [ 1 ]; return c < arr [ 2 ]; }","title":"Exerc\u00edcio 2 - fun\u00e7\u00e3o func_que_recebe_array"},{"location":"aulas/09-arrays/#exercicio-3-funcao-first_neg","text":"Veja agora o c\u00f3digo abaixo e responda. Dump of assembler code for function first_neg : 0 x0000 <+ 0 > : mov $0x0 , %eax 0 x0005 <+ 5 > : cmp %esi , %eax 0 x0007 <+ 7 > : jge 0x17 < first_neg + 23 > 0 x0009 <+ 9 > : movslq %eax , %rdx 0 x000c <+ 12 > : cmpl $0x0 ,( %rdi , %rdx , 4 ) 0 x0010 <+ 16 > : js 0x17 < first_neg + 23 > 0 x0012 <+ 18 > : add $0x1 , %eax 0 x0015 <+ 21 > : jmp 0x5 < first_neg + 5 > 0 x0017 <+ 23 > : repz retq Exercise A fun\u00e7\u00e3o acima usa v\u00e1rios registradores. Para facilitar a descoberta de quais s\u00e3o par\u00e2metros da fun\u00e7\u00e3o anote abaixo cada registrador usado e, ao lado, a linha do primeiro uso e se esse uso foi leitura ou escrita. Answer Em <first_neg+0> , usa-se %eax para escrita . Em <first_neg+5> , usa-se %esi para leitura . Em <first_neg+12> , usa-se %rdi para leitura . Exercise Desenhe setas indicando o destino dos pulos no c\u00f3digo acima. Voc\u00ea consegue idenfiticar quais estruturas de controle? Entre quais linhas? Answer Confira com os professores Exercise Fa\u00e7a uma vers\u00e3o em C usando if-goto do c\u00f3digo acima. Answer int first_neg ( int * vec , int n ) { res = 0 ; loop : if ( res >= n ) { goto retorno ; } if ( vec [ res ] < 0 ) { goto retorno ; } res = res + 1 ; goto loop : retorno : return res ; } Exercise Transforme seu c\u00f3digo em uma vers\u00e3o leg\u00edvel. Answer int first_neg ( int * vec , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( vec [ i ] < 0 ) { return i ; } } }","title":"Exerc\u00edcio 3 - fun\u00e7\u00e3o first_neg"},{"location":"aulas/10-revisao/","text":"10 - Revis\u00e3o \u00b6 Na aula de hoje iremos revisar nossas atividades com Assembly e representa\u00e7\u00e3o de inteiros. Quando tiver d\u00favidas, chame os professores. Ex1.c \u00b6 Abra o c\u00f3digo-fonte ex1.c e confira a fun\u00e7\u00e3o main . Compile e execute o exerc\u00edcio 1. Em seguida, resposta: Exercise O valor apresentado na sa\u00edda confere com o presente no c\u00f3digo? Por que isto acontece? Answer O valor -1 em complemento de 2 \u00e9 representado como uma sequ\u00eancia de 1's. Ao ser atribu\u00eddo em uma unsigned short, teremos dezesseis 1's, mas que ser\u00e3o interpretados como unsigned. Somando 2^0 + 2^1 + \\dots + 2^{15} = 65535 2^0 + 2^1 + \\dots + 2^{15} = 65535 Exercise Qual o maior valor que pode ser armazenado em uma vari\u00e1vel unsigned short ? Answer A vari\u00e1vel ser\u00e1 de 2 bytes sem sinal, assim o maior valor \u00e9 2^{16}-1 = 65535 2^{16}-1 = 65535 Exercise O que acontece quando tentamos armazenar um valor maior que o suportado pelo tipo de dados? Ex: atribuir 80000 para uma unsigned short . Answer Apenas os 16 bits menos significativos ser\u00e3o considerados. Ex2.c \u00b6 Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex2.c com $ gcc -Wall -std = c99 -Og ex2.c -c -o ex2.o Abra o arquivo ex2.o com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Liste as vari\u00e1veis globais e fun\u00e7\u00f5es existentes. Answer Fun\u00e7\u00f5es func1 e func2 . Sem vari\u00e1veis globais. Analise a fun\u00e7\u00e3o func1 com o gdb e responda: Exercise Com base nos registradores utilizados, escreva a assinatura da fun\u00e7\u00e3o func1 . Answer void func1 ( unsigned short * vec ) A partir de um ponteiro armazenado em %rdi , s\u00e3o feitas v\u00e1rias atribui\u00e7\u00f5es espa\u00e7adas em dois bytes, indicando ser um ponteiro para short . Exercise Em movw $0x0,(%rdi) , qual a opera\u00e7\u00e3o realizada e o que significa o trecho (%rdi) ? Answer A opera\u00e7\u00e3o \u00e9 vec[0] = 0 ou *vec = 0 . Como a opera\u00e7\u00e3o \u00e9 um MOV , ent\u00e3o (%rdi) representa uma dereferencia\u00e7\u00e3o de ponteiro. Tip Veja a se\u00e7\u00e3o Acesso a elementos constantes da aula 09 - Arrays Exercise Em movw $0x14,0x4(%rdi) , qual a opera\u00e7\u00e3o realizada e o que significa o trecho 0x4(%rdi) ? Answer A opera\u00e7\u00e3o \u00e9 vec[2] = 20 . Em 0x4(%rdi) , indicamos que queremos acessar o endere\u00e7o %rdi + 4 bytes . Tip Acese na aula 05-Condicionais a explica\u00e7\u00e3o sobre as vari\u00e2ntes da instru\u00e7\u00e3o mov Exercise Fa\u00e7a uma vers\u00e3o leg\u00edvel em C da fun\u00e7\u00e3o func1 . Answer void func1 ( unsigned short * vec ) { vec [ 0 ] = 0 ; vec [ 1 ] = 10 ; vec [ 2 ] = 20 ; } Analise a fun\u00e7\u00e3o func2 com o gdb e responda: Exercise Com base nos registradores utilizados, escreva a assinatura da fun\u00e7\u00e3o func2 . Answer void func2 ( int * vec , int n ) Caso restem d\u00favidas, chame os professores. Exercise Qual a opera\u00e7\u00e3o realizada em lea (%rax,%rax,4),%edx na fun\u00e7\u00e3o func2 ? Answer \u00c9 uma opera\u00e7\u00e3o aritm\u00e9tica onde o valor armazenado em %rax \u00e9 multiplicado por 5 e armazenado em %edx . Exercise Qual a opera\u00e7\u00e3o realizada em add %edx,%edx na fun\u00e7\u00e3o func2 ? Answer \u00c9 uma opera\u00e7\u00e3o aritm\u00e9tica onde o valor armazenado em %edx \u00e9 somado consigmo mesmo e armazenado em %edx . Isto \u00e9 equivalente a fazer var = var * 2 . Exercise Voc\u00ea conseguiria agregar as opera\u00e7\u00f5es lea (%rax,%rax,4),%edx e add %edx,%edx em uma \u00fanica opera\u00e7\u00e3o aritm\u00e9tica mais simples? Answer Supondo que %eax representa a vari\u00e1vel i , ent\u00e3o a jun\u00e7\u00e3o das duas opera\u00e7\u00f5es \u00e9 equivalente a fazer i * 10 , cujo resultado \u00e9 armazenado em %edx . Exercise Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : void func2 ( int * vec , int n ) { int i = 0 ; int aux ; loop : if ( i >= n ) { goto retorna : } aux = i * 5 ; aux = aux + aux ; vec [ i ] = aux ; i = i + 1 ; goto loop ; retorna : return ; } Vers\u00e3o C : void func2 ( int * vec , int n ) { for ( int i = 0 ; i < n ; i ++ ) { vec [ i ] = i * 10 ; } } Caso restem d\u00favidas, chame os professores. Ex3.c \u00b6 Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex3.c com: $ gcc -Wall -std = c99 -Og ex3.c -o ex3 Abra o arquivo ex3 com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Liste as fun\u00e7\u00f5es e vari\u00e1veis globais dispon\u00edveis. Answer Vari\u00e1vel global v_global . Fun\u00e7\u00f5es func1 , func2 , func3 , func4 e main . Exercise Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es func1 e func2 . Existe alguma semelhan\u00e7a? Answer Ambas fazem opera\u00e7\u00f5es com registradores. Por\u00e9m func2 faz a leitura de algum valor de mem\u00f3ria e armazenando no retorno da fun\u00e7\u00e3o, uma vari\u00e1vel global. J\u00e1 func1 apenas faz uma opera\u00e7\u00e3o aritm\u00e9tica com o par\u00e2metro recebido. int func1 ( int n ) { int x = 10 ; return x + n ; } int func2 ( int n ) { return v_global + n ; } Tip Fique atento a chamadas de vari\u00e1veis globais. Utilize o comando x para imprimir o conte\u00fado de um endere\u00e7o. Veja mais em https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html Exemplo: x/d 0x100 x/s 0x100 Exercise Defina a assinatura da fun\u00e7\u00e3o func3 e fa\u00e7a sua tradu\u00e7\u00e3o para C. Answer int func3 ( int n , int mult ) { return v_global + n * mult ; } Exercise Defina a assinatura da fun\u00e7\u00e3o func4 . Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : void func4 () { res = func1 ( 5 ); if ( res <= 20 ) { goto faz_algo ; } printf ( \"O novo valor eh maior que 20\" ); retorna : return ; faz_algo : printf ( \"O novo valor nao eh maior que 20\" ); goto retorna ; } Vers\u00e3o C : void func4 () { int aux = func1 ( 5 ); if ( aux > 20 ) { printf ( \"O novo valor eh maior que 20\" ); } else { printf ( \"O novo valor nao eh maior que 20\" ); } } Ex4.c \u00b6 Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex4.c com: $ gcc -Wall -std = c99 -fno-stack-protector -Og ex4.c -o ex4 ` Abra o arquivo ex4 com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Defina a assinatura da fun\u00e7\u00e3o ex4 . Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : int ex4 () { unsigned short n ; int ret ; int i ; int aux ; scanf ( \"%hu\" , & n ); loop : aux = n ; if ( aux <= i ) { goto retorna ; } ret = ret + i * 4 ; i = i + 1 ; goto loop ; retorna : return ret ; } Vers\u00e3o C : ```C include \u00b6 int ex4() { unsigned short n; scanf(\"%hu\", &n); int res = 0; int i = 1; while (i < n) { res += (i*4); i++; } return res; } int main() { return 0; } ``` Tip Observe sempre as chamadas de vari\u00e1veis globais e strings (relativos a %rip ) e acessos \u00e0 stack (relativos a %rsp ). Exemplo de prova \u00b6 Al\u00e9m dos exerc\u00edcios de revis\u00e3o feitos na aula, voc\u00ea encontrar\u00e1 no reposit\u00f3rio da disciplina um arquivo ai_arquivos.zip . Ele um arquivo semelhante ao que receber\u00e3o no dia da AI de SisHard. No dia da prova, voc\u00ea ter\u00e1 que baixar o zip, descompactar, resolver os exerc\u00edcios, compactar e anexar no Blackboard. Tip Leia o README.md para saber o que \u00e9 esperado em cada quest\u00e3o! Tip Leia o README.md para saber como voc\u00ea ser\u00e1 avaliado!","title":"10 - Revis\u00e3o"},{"location":"aulas/10-revisao/#10-revisao","text":"Na aula de hoje iremos revisar nossas atividades com Assembly e representa\u00e7\u00e3o de inteiros. Quando tiver d\u00favidas, chame os professores.","title":"10 - Revis\u00e3o"},{"location":"aulas/10-revisao/#ex1c","text":"Abra o c\u00f3digo-fonte ex1.c e confira a fun\u00e7\u00e3o main . Compile e execute o exerc\u00edcio 1. Em seguida, resposta: Exercise O valor apresentado na sa\u00edda confere com o presente no c\u00f3digo? Por que isto acontece? Answer O valor -1 em complemento de 2 \u00e9 representado como uma sequ\u00eancia de 1's. Ao ser atribu\u00eddo em uma unsigned short, teremos dezesseis 1's, mas que ser\u00e3o interpretados como unsigned. Somando 2^0 + 2^1 + \\dots + 2^{15} = 65535 2^0 + 2^1 + \\dots + 2^{15} = 65535 Exercise Qual o maior valor que pode ser armazenado em uma vari\u00e1vel unsigned short ? Answer A vari\u00e1vel ser\u00e1 de 2 bytes sem sinal, assim o maior valor \u00e9 2^{16}-1 = 65535 2^{16}-1 = 65535 Exercise O que acontece quando tentamos armazenar um valor maior que o suportado pelo tipo de dados? Ex: atribuir 80000 para uma unsigned short . Answer Apenas os 16 bits menos significativos ser\u00e3o considerados.","title":"Ex1.c"},{"location":"aulas/10-revisao/#ex2c","text":"Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex2.c com $ gcc -Wall -std = c99 -Og ex2.c -c -o ex2.o Abra o arquivo ex2.o com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Liste as vari\u00e1veis globais e fun\u00e7\u00f5es existentes. Answer Fun\u00e7\u00f5es func1 e func2 . Sem vari\u00e1veis globais. Analise a fun\u00e7\u00e3o func1 com o gdb e responda: Exercise Com base nos registradores utilizados, escreva a assinatura da fun\u00e7\u00e3o func1 . Answer void func1 ( unsigned short * vec ) A partir de um ponteiro armazenado em %rdi , s\u00e3o feitas v\u00e1rias atribui\u00e7\u00f5es espa\u00e7adas em dois bytes, indicando ser um ponteiro para short . Exercise Em movw $0x0,(%rdi) , qual a opera\u00e7\u00e3o realizada e o que significa o trecho (%rdi) ? Answer A opera\u00e7\u00e3o \u00e9 vec[0] = 0 ou *vec = 0 . Como a opera\u00e7\u00e3o \u00e9 um MOV , ent\u00e3o (%rdi) representa uma dereferencia\u00e7\u00e3o de ponteiro. Tip Veja a se\u00e7\u00e3o Acesso a elementos constantes da aula 09 - Arrays Exercise Em movw $0x14,0x4(%rdi) , qual a opera\u00e7\u00e3o realizada e o que significa o trecho 0x4(%rdi) ? Answer A opera\u00e7\u00e3o \u00e9 vec[2] = 20 . Em 0x4(%rdi) , indicamos que queremos acessar o endere\u00e7o %rdi + 4 bytes . Tip Acese na aula 05-Condicionais a explica\u00e7\u00e3o sobre as vari\u00e2ntes da instru\u00e7\u00e3o mov Exercise Fa\u00e7a uma vers\u00e3o leg\u00edvel em C da fun\u00e7\u00e3o func1 . Answer void func1 ( unsigned short * vec ) { vec [ 0 ] = 0 ; vec [ 1 ] = 10 ; vec [ 2 ] = 20 ; } Analise a fun\u00e7\u00e3o func2 com o gdb e responda: Exercise Com base nos registradores utilizados, escreva a assinatura da fun\u00e7\u00e3o func2 . Answer void func2 ( int * vec , int n ) Caso restem d\u00favidas, chame os professores. Exercise Qual a opera\u00e7\u00e3o realizada em lea (%rax,%rax,4),%edx na fun\u00e7\u00e3o func2 ? Answer \u00c9 uma opera\u00e7\u00e3o aritm\u00e9tica onde o valor armazenado em %rax \u00e9 multiplicado por 5 e armazenado em %edx . Exercise Qual a opera\u00e7\u00e3o realizada em add %edx,%edx na fun\u00e7\u00e3o func2 ? Answer \u00c9 uma opera\u00e7\u00e3o aritm\u00e9tica onde o valor armazenado em %edx \u00e9 somado consigmo mesmo e armazenado em %edx . Isto \u00e9 equivalente a fazer var = var * 2 . Exercise Voc\u00ea conseguiria agregar as opera\u00e7\u00f5es lea (%rax,%rax,4),%edx e add %edx,%edx em uma \u00fanica opera\u00e7\u00e3o aritm\u00e9tica mais simples? Answer Supondo que %eax representa a vari\u00e1vel i , ent\u00e3o a jun\u00e7\u00e3o das duas opera\u00e7\u00f5es \u00e9 equivalente a fazer i * 10 , cujo resultado \u00e9 armazenado em %edx . Exercise Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : void func2 ( int * vec , int n ) { int i = 0 ; int aux ; loop : if ( i >= n ) { goto retorna : } aux = i * 5 ; aux = aux + aux ; vec [ i ] = aux ; i = i + 1 ; goto loop ; retorna : return ; } Vers\u00e3o C : void func2 ( int * vec , int n ) { for ( int i = 0 ; i < n ; i ++ ) { vec [ i ] = i * 10 ; } } Caso restem d\u00favidas, chame os professores.","title":"Ex2.c"},{"location":"aulas/10-revisao/#ex3c","text":"Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex3.c com: $ gcc -Wall -std = c99 -Og ex3.c -o ex3 Abra o arquivo ex3 com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Liste as fun\u00e7\u00f5es e vari\u00e1veis globais dispon\u00edveis. Answer Vari\u00e1vel global v_global . Fun\u00e7\u00f5es func1 , func2 , func3 , func4 e main . Exercise Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es func1 e func2 . Existe alguma semelhan\u00e7a? Answer Ambas fazem opera\u00e7\u00f5es com registradores. Por\u00e9m func2 faz a leitura de algum valor de mem\u00f3ria e armazenando no retorno da fun\u00e7\u00e3o, uma vari\u00e1vel global. J\u00e1 func1 apenas faz uma opera\u00e7\u00e3o aritm\u00e9tica com o par\u00e2metro recebido. int func1 ( int n ) { int x = 10 ; return x + n ; } int func2 ( int n ) { return v_global + n ; } Tip Fique atento a chamadas de vari\u00e1veis globais. Utilize o comando x para imprimir o conte\u00fado de um endere\u00e7o. Veja mais em https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html Exemplo: x/d 0x100 x/s 0x100 Exercise Defina a assinatura da fun\u00e7\u00e3o func3 e fa\u00e7a sua tradu\u00e7\u00e3o para C. Answer int func3 ( int n , int mult ) { return v_global + n * mult ; } Exercise Defina a assinatura da fun\u00e7\u00e3o func4 . Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : void func4 () { res = func1 ( 5 ); if ( res <= 20 ) { goto faz_algo ; } printf ( \"O novo valor eh maior que 20\" ); retorna : return ; faz_algo : printf ( \"O novo valor nao eh maior que 20\" ); goto retorna ; } Vers\u00e3o C : void func4 () { int aux = func1 ( 5 ); if ( aux > 20 ) { printf ( \"O novo valor eh maior que 20\" ); } else { printf ( \"O novo valor nao eh maior que 20\" ); } }","title":"Ex3.c"},{"location":"aulas/10-revisao/#ex4c","text":"Neste exerc\u00edcio iremos fazer engenharia reversa de Assembly para C. Os c\u00f3digos-fonte est\u00e3o dispon\u00edveis no reposit\u00f3rio, mas evite abri-los antes de ter feito pelo menos uma primeira vers\u00e3o da engenharia reversa. Compile o ex4.c com: $ gcc -Wall -std = c99 -fno-stack-protector -Og ex4.c -o ex4 ` Abra o arquivo ex4 com o gdb sem abrir o c\u00f3digo-fonte e responda: Exercise Defina a assinatura da fun\u00e7\u00e3o ex4 . Fa\u00e7a uma vers\u00e3o em C do c\u00f3digo acima usando somente if-goto . Escreva, ent\u00e3o, ao lado desta vers\u00e3o um c\u00f3digo leg\u00edvel em C . Answer Vers\u00e3o if-goto : int ex4 () { unsigned short n ; int ret ; int i ; int aux ; scanf ( \"%hu\" , & n ); loop : aux = n ; if ( aux <= i ) { goto retorna ; } ret = ret + i * 4 ; i = i + 1 ; goto loop ; retorna : return ret ; } Vers\u00e3o C : ```C","title":"Ex4.c"},{"location":"aulas/10-revisao/#include","text":"int ex4() { unsigned short n; scanf(\"%hu\", &n); int res = 0; int i = 1; while (i < n) { res += (i*4); i++; } return res; } int main() { return 0; } ``` Tip Observe sempre as chamadas de vari\u00e1veis globais e strings (relativos a %rip ) e acessos \u00e0 stack (relativos a %rsp ).","title":"include "},{"location":"aulas/10-revisao/#exemplo-de-prova","text":"Al\u00e9m dos exerc\u00edcios de revis\u00e3o feitos na aula, voc\u00ea encontrar\u00e1 no reposit\u00f3rio da disciplina um arquivo ai_arquivos.zip . Ele um arquivo semelhante ao que receber\u00e3o no dia da AI de SisHard. No dia da prova, voc\u00ea ter\u00e1 que baixar o zip, descompactar, resolver os exerc\u00edcios, compactar e anexar no Blackboard. Tip Leia o README.md para saber o que \u00e9 esperado em cada quest\u00e3o! Tip Leia o README.md para saber como voc\u00ea ser\u00e1 avaliado!","title":"Exemplo de prova"},{"location":"labs/hackerlab/","text":"Hackerlab \u00b6 Introdu\u00e7\u00e3o \u00b6 O prop\u00f3sito desta atividade \u00e9 torn\u00e1-los proficientes na engenharia reversa de execut\u00e1veis. Cada um de voc\u00eas recebeu um execut\u00e1vel app que pede uma s\u00e9rie de senhas para ser desativado. Estas senhas devem ser descobertas atrav\u00e9s da an\u00e1lise do c\u00f3digo Assembly do execut\u00e1vel. O seu execut\u00e1vel foi deixado no seu reposit\u00f3rio de entregas da disciplina. Ao execut\u00e1-lo, confira se o seu nome \u00e9 a primeira sa\u00edda. Em caso negativo, entre em contato com o professor imediatamente. Entrega \u00b6 Voc\u00ea dever\u00e1 submeter um arquivo contendo as senhas usadas para desativar cada n\u00edvel. Cada senha dever\u00e1 estar em uma linha. O arquivo entregue deve funcionar como entrada para liberar acesso \u00e0 aplica\u00e7\u00e3o! $ ./app < solucao.txt Aten\u00e7\u00e3o : o arquivo deve se chamar solucao.txt , ser editado no Linux e codificado como UTF-8. Para que sua solu\u00e7\u00e3o seja considerada pelo servidor de corre\u00e7\u00e3o, ap\u00f3s subir suas altera\u00e7\u00f5es, fa\u00e7a uma tag com o padr\u00e3o de nomenclatura lab1.x.y , substituindo x e y por qualquer n\u00famero inteiro! Ex: $ git tag -a lab1.0.1 -m \"lab1.0.1\" # git push origin lab1.0.1 Pontua\u00e7\u00e3o \u00b6 S\u00e3o dez n\u00edveis e cada um vale 1,0 de nota. Prazo \u00b6 Veja mais em https://insper.github.io/SistemasHardwareSoftware/sobre/","title":"Hackerlab"},{"location":"labs/hackerlab/#hackerlab","text":"","title":"Hackerlab"},{"location":"labs/hackerlab/#introducao","text":"O prop\u00f3sito desta atividade \u00e9 torn\u00e1-los proficientes na engenharia reversa de execut\u00e1veis. Cada um de voc\u00eas recebeu um execut\u00e1vel app que pede uma s\u00e9rie de senhas para ser desativado. Estas senhas devem ser descobertas atrav\u00e9s da an\u00e1lise do c\u00f3digo Assembly do execut\u00e1vel. O seu execut\u00e1vel foi deixado no seu reposit\u00f3rio de entregas da disciplina. Ao execut\u00e1-lo, confira se o seu nome \u00e9 a primeira sa\u00edda. Em caso negativo, entre em contato com o professor imediatamente.","title":"Introdu\u00e7\u00e3o"},{"location":"labs/hackerlab/#entrega","text":"Voc\u00ea dever\u00e1 submeter um arquivo contendo as senhas usadas para desativar cada n\u00edvel. Cada senha dever\u00e1 estar em uma linha. O arquivo entregue deve funcionar como entrada para liberar acesso \u00e0 aplica\u00e7\u00e3o! $ ./app < solucao.txt Aten\u00e7\u00e3o : o arquivo deve se chamar solucao.txt , ser editado no Linux e codificado como UTF-8. Para que sua solu\u00e7\u00e3o seja considerada pelo servidor de corre\u00e7\u00e3o, ap\u00f3s subir suas altera\u00e7\u00f5es, fa\u00e7a uma tag com o padr\u00e3o de nomenclatura lab1.x.y , substituindo x e y por qualquer n\u00famero inteiro! Ex: $ git tag -a lab1.0.1 -m \"lab1.0.1\" # git push origin lab1.0.1","title":"Entrega"},{"location":"labs/hackerlab/#pontuacao","text":"S\u00e3o dez n\u00edveis e cada um vale 1,0 de nota.","title":"Pontua\u00e7\u00e3o"},{"location":"labs/hackerlab/#prazo","text":"Veja mais em https://insper.github.io/SistemasHardwareSoftware/sobre/","title":"Prazo"},{"location":"labs/processos/","text":"Lab de Processos e Bibliotecas \u00b6 No lab de Sistemas Operacionais iremos trabalhar com bibliotecas e processos para a cria\u00e7\u00e3o de um programa similar ao wget . Nosso programa, chamado de web_downloader , far\u00e1 download de p\u00e1ginas web usando a biblioteca libCurl . Restri\u00e7\u00f5es \u00b6 Este exerc\u00edcio serve como avalia\u00e7\u00e3o dos conceitos vistos na disciplina. Portanto, algumas restri\u00e7\u00f5es ser\u00e3o aplicadas aos c\u00f3digo de voc\u00eas: todo trabalho com arquivos dever\u00e1 ser feito usando as APIs POSIX vistas em aula seu programa dever\u00e1 compilar sem warnings usando as op\u00e7\u00f5es -Wall -Wno-unused-result -Og -g -lcurl voc\u00ea dever\u00e1 usar a biblioteca libCurl para realizar o download das p\u00e1ginas. Veja sua documenta\u00e7\u00e3o para aprender a us\u00e1-la se voc\u00ea usar algum trecho de c\u00f3digo da documenta\u00e7\u00e3o (ou de outra fonte), coloque uma atribui\u00e7\u00e3o em um coment\u00e1rio no c\u00f3digo. Avalia\u00e7\u00e3o \u00b6 O programa ser\u00e1 avaliado usando uma rubrica que descreve as funcionalidades implementadas. Quanto maior o n\u00famero de funcionalidades maior ser\u00e1 a nota. Voc\u00ea dever\u00e1 colocar sua entrega na pasta lab-processos na raiz do reposit\u00f3rio de atividades. Conceito I \u00b6 O programa n\u00e3o compila O programa n\u00e3o implementa algum dos requisitos da rubrica D . Conceito D \u00b6 O programa compila com warnings. O programa roda na linha de comando como abaixo, salvando o resultado como exemplo_com_pagina.html , ou seja, ignorando http:// e https:// , substituindo todas barras e pontos (exceto o \u00faltimo) por _ . $> web_downloader http://exemplo.com/pagina.html Conceito C \u00b6 O programa compila sem warnings. O programa recebe uma flag -f seguida pelo nome de um arquivo. Seu programa dever\u00e1 ler o arquivo e fazer o download de cada url dentro do arquivo. Voc\u00ea pode supor que cada linha do arquivo cont\u00e9m exatamente uma URL. As regras para o nome do arquivo correspondente s\u00e3o as mesmas do item anterior. $> web_downloader -f lista_download.txt O download de cada p\u00e1gina \u00e9 feito em um processo separado e em paralelo. Voc\u00ea deve observar uma diminui\u00e7\u00e3o grande no tempo de download de p\u00e1ginas pequenas. Ao terminar de baixar uma p\u00e1gina, voc\u00ea dever\u00e1 mostrar a mensagem \"{url} baixada com sucesso!\" Conceito B \u00b6 O processo principal s\u00f3 termina depois que todos os arquivos foram baixados. O programa abre at\u00e9 N processos em paralelo. Se houver mais que N urls ent\u00e3o os processos dever\u00e3o sempre existir no m\u00e1ximo N+1 processos ( N para fazer download mais o original). Esse valor \u00e9 passado pela linha de comando via flag -N . Se nada for passado assuma N=4 . Conceito A \u00b6 As mensagens de finaliza\u00e7\u00e3o de baixar uma p\u00e1gina s\u00e3o mostradas sem estar embaralhadas mesmo se v\u00e1rios processos terminarem ao mesmo tempo. Ao apertar Ctrl+C o programa pergunta se o usu\u00e1rio deseja realmente sair. Se sim, todas as transfer\u00eancias s\u00e3o paradas e os arquivos que n\u00e3o foram baixados at\u00e9 o fim s\u00e3o deletados. Se o download falhar por alguma raz\u00e3o seu programa dever\u00e1 mostrar a mensagem \"{url} n\u00e3o pode ser baixada.\". Nenhum arquivo dever\u00e1 ser produzido neste caso. Prazo: \u00b6 Clique aqui! .","title":"Lab de Processos e Bibliotecas"},{"location":"labs/processos/#lab-de-processos-e-bibliotecas","text":"No lab de Sistemas Operacionais iremos trabalhar com bibliotecas e processos para a cria\u00e7\u00e3o de um programa similar ao wget . Nosso programa, chamado de web_downloader , far\u00e1 download de p\u00e1ginas web usando a biblioteca libCurl .","title":"Lab de Processos e Bibliotecas"},{"location":"labs/processos/#restricoes","text":"Este exerc\u00edcio serve como avalia\u00e7\u00e3o dos conceitos vistos na disciplina. Portanto, algumas restri\u00e7\u00f5es ser\u00e3o aplicadas aos c\u00f3digo de voc\u00eas: todo trabalho com arquivos dever\u00e1 ser feito usando as APIs POSIX vistas em aula seu programa dever\u00e1 compilar sem warnings usando as op\u00e7\u00f5es -Wall -Wno-unused-result -Og -g -lcurl voc\u00ea dever\u00e1 usar a biblioteca libCurl para realizar o download das p\u00e1ginas. Veja sua documenta\u00e7\u00e3o para aprender a us\u00e1-la se voc\u00ea usar algum trecho de c\u00f3digo da documenta\u00e7\u00e3o (ou de outra fonte), coloque uma atribui\u00e7\u00e3o em um coment\u00e1rio no c\u00f3digo.","title":"Restri\u00e7\u00f5es"},{"location":"labs/processos/#avaliacao","text":"O programa ser\u00e1 avaliado usando uma rubrica que descreve as funcionalidades implementadas. Quanto maior o n\u00famero de funcionalidades maior ser\u00e1 a nota. Voc\u00ea dever\u00e1 colocar sua entrega na pasta lab-processos na raiz do reposit\u00f3rio de atividades.","title":"Avalia\u00e7\u00e3o"},{"location":"labs/processos/#conceito-i","text":"O programa n\u00e3o compila O programa n\u00e3o implementa algum dos requisitos da rubrica D .","title":"Conceito I"},{"location":"labs/processos/#conceito-d","text":"O programa compila com warnings. O programa roda na linha de comando como abaixo, salvando o resultado como exemplo_com_pagina.html , ou seja, ignorando http:// e https:// , substituindo todas barras e pontos (exceto o \u00faltimo) por _ . $> web_downloader http://exemplo.com/pagina.html","title":"Conceito D"},{"location":"labs/processos/#conceito-c","text":"O programa compila sem warnings. O programa recebe uma flag -f seguida pelo nome de um arquivo. Seu programa dever\u00e1 ler o arquivo e fazer o download de cada url dentro do arquivo. Voc\u00ea pode supor que cada linha do arquivo cont\u00e9m exatamente uma URL. As regras para o nome do arquivo correspondente s\u00e3o as mesmas do item anterior. $> web_downloader -f lista_download.txt O download de cada p\u00e1gina \u00e9 feito em um processo separado e em paralelo. Voc\u00ea deve observar uma diminui\u00e7\u00e3o grande no tempo de download de p\u00e1ginas pequenas. Ao terminar de baixar uma p\u00e1gina, voc\u00ea dever\u00e1 mostrar a mensagem \"{url} baixada com sucesso!\"","title":"Conceito C"},{"location":"labs/processos/#conceito-b","text":"O processo principal s\u00f3 termina depois que todos os arquivos foram baixados. O programa abre at\u00e9 N processos em paralelo. Se houver mais que N urls ent\u00e3o os processos dever\u00e3o sempre existir no m\u00e1ximo N+1 processos ( N para fazer download mais o original). Esse valor \u00e9 passado pela linha de comando via flag -N . Se nada for passado assuma N=4 .","title":"Conceito B"},{"location":"labs/processos/#conceito-a","text":"As mensagens de finaliza\u00e7\u00e3o de baixar uma p\u00e1gina s\u00e3o mostradas sem estar embaralhadas mesmo se v\u00e1rios processos terminarem ao mesmo tempo. Ao apertar Ctrl+C o programa pergunta se o usu\u00e1rio deseja realmente sair. Se sim, todas as transfer\u00eancias s\u00e3o paradas e os arquivos que n\u00e3o foram baixados at\u00e9 o fim s\u00e3o deletados. Se o download falhar por alguma raz\u00e3o seu programa dever\u00e1 mostrar a mensagem \"{url} n\u00e3o pode ser baixada.\". Nenhum arquivo dever\u00e1 ser produzido neste caso.","title":"Conceito A"},{"location":"labs/processos/#prazo","text":"Clique aqui! .","title":"Prazo:"}]}